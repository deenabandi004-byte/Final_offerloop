# Email Template System & Signoff Personalization — Investigation & Implementation Plan

## Step 1 & 2: Investigation Summary

### 1. Backend email generation flow

**Entry points:**

| Entry point | File | Template usage |
|-------------|------|----------------|
| **POST /api/emails/generate-and-draft** (Discover Contacts) | `backend/app/routes/emails.py` → `generate_and_draft()` | Does **not** pass `template_instructions` or `email_template_purpose` to `batch_generate_emails`. Defaults to empty string and `None` → backend uses default networking prompt and hardcoded "Best," signature. |
| **Free-run / Pro-run / Prompt-search** | `backend/app/routes/runs.py` | Resolves template via `_resolve_email_template(email_template, user_id, db)` → gets `template_instructions` and `email_template_purpose` from request body or Firestore `users/{uid}.emailTemplate`, then passes them to `batch_generate_emails`. |

**Template resolution (`backend/app/routes/runs.py`):**

- `_resolve_email_template(email_template_override, user_id, db)`:
  - Reads purpose, stylePreset, customInstructions from request override or from Firestore `users/{uid}.emailTemplate`.
  - Calls `get_template_instructions(purpose, style_preset, custom_instructions)` from `backend/email_templates.py`.
  - Returns `(template_instructions: str, email_template_purpose: str|None)`.

**`backend/email_templates.py`:**

- `get_template_instructions(purpose, style_preset, custom_instructions)`:
  - If purpose is None/networking, no style, no custom → returns `""` (backwards compatible).
  - Otherwise concatenates: purpose base_prompt (from `EMAIL_PURPOSE_PRESETS`) + style instructions (from `EMAIL_STYLE_PRESETS`) + "CUSTOM INSTRUCTIONS (from user):" + custom_instructions.
- Style presets (e.g. casual, professional) include **signoff hints** in natural language, e.g. "Sign off casually: 'Thanks,' or 'Cheers,' then name" or "Sign off with 'Best regards,' or 'Thank you,' then full name". These are **prompt instructions to the LLM**, not stored user preferences.

**`backend/app/services/reply_generation.py`:**

- `batch_generate_emails(..., template_instructions="", email_template_purpose=None, ...)`:
  - Builds `context_block` (sender name, university, major, year, contacts, fit_context).
  - Builds `requirements_block` (EMAIL STRUCTURE) which **hardcodes**:
    - `SIGNATURE (exactly this format):\nBest,\n[Full Name]\n[University] | Class of [Year]`
  - Full prompt = `build_template_prompt(context_block, template_instructions, requirements_block)` → `context_block + "\n\n" + template_instructions + "\n\n" + requirements_block`.
  - LLM returns JSON `{ "0": { "subject", "body" }, ... }`. The **body** is expected to already contain the closing/signature as generated by the LLM (following the hardcoded "Best," format in requirements_block).
  - Post-processing: inserts "I've attached my resume below" before sign-off patterns (`Best,`, `Best regards,`, `Thank you,`, `Thanks,`) when purpose is networking/referral.
  - Fallback emails (on error) use `Thank you,\n{signature}` with `signature = user_info.get('name','') or "Best regards"`.

**`backend/app/routes/emails.py` (generate-and-draft):**

- After getting `r["body"]` from batch_generate_emails (or existing contact email), it **optionally appends a signature** if the body doesn’t already look like it has one:
  - Detects signature via substrings: 'best,', 'best regards', 'thank you', user name, email, university in the last 200 chars.
  - If no signature detected and `user_profile` exists, builds:
    - `signature_lines = ["Best,", user_name, university | Class of year, user_email]`
    - `signature_text = "\n" + "\n".join(signature_lines)` and appends to body.
  - So the **draft** can get a second signature block from `user_profile` (name, email, university, year) with **hardcoded "Best,"** in emails.py.

**Where the signoff/closing is determined:**

1. **LLM output:** The `requirements_block` in reply_generation.py tells the model to use "Best," and "[Full Name]" and "[University] | Class of [Year]". So the **phrase "Best,"** and the **structure** (closing line + name + university line) are **hardcoded in the prompt**, not user-configurable.
2. **Style presets:** Only give the LLM **hints** (e.g. "Sign off with 'Thanks,' then name"); they don’t override the structural block.
3. **emails.py fallback signature:** When the backend decides the body has no signature, it appends "Best," + name + university/year + email — again **hardcoded "Best,"**.

There is **no** stored field for user-chosen signoff phrase or custom signature block today.

---

### 2. Frontend template UI

**Relevant files:**

- **`connect-grow-hire/src/pages/EmailTemplatesPage.tsx`** — Full-page "Email template" (route: `/contact-search/templates`). Purpose pills (Networking, Referral, Follow-Up, Custom), optional custom instructions, Save as default / Apply to search. **No signoff or signature block controls.**
- **`connect-grow-hire/src/components/EmailTemplateModal.tsx`** — Modal version: purpose, style preset dropdown, custom instructions. **No signoff or signature block controls.**
- **`connect-grow-hire/src/services/api.ts`** — `EmailTemplate` type: `{ purpose, stylePreset, customInstructions }`. `getEmailTemplate()`, `saveEmailTemplate()`, `getEmailTemplatePresets()`.

**Current customization:** Purpose, style preset, and free-form custom instructions only. No UI for signoff phrase or signature block (name, title, university, year, phone, LinkedIn).

---

### 3. Data model (Firestore)

- **Collection:** `users`
- **Document:** `users/{uid}`
- **Field:** `emailTemplate` (map), written by `backend/app/routes/email_template.py` on POST `/api/email-template`:
  - `purpose`: string | null (e.g. "networking", "referral", "custom")
  - `stylePreset`: string | null (e.g. "casual", "professional")
  - `customInstructions`: string
  - `updatedAt`: timestamp

**No** signoff phrase or signature-block fields exist today.

---

### 4. Complete flow (template settings → API → LLM → output)

1. **User** sets purpose/style/custom on Email Templates page or modal → **Save** → POST `/api/email-template` → Firestore `users/{uid}.emailTemplate` updated.
2. **Discover Contacts:** Frontend calls POST `/api/emails/generate-and-draft` with contacts, userProfile, resumeUrl, resumeFileName. **Does not send emailTemplate.** Backend does **not** load `emailTemplate` for this route; it calls `batch_generate_emails(..., template_instructions="", email_template_purpose=None)` → default networking prompt with hardcoded "Best," signature.
3. **Free/Pro run or Prompt-search:** Request body (or form) includes `emailTemplate`. Backend reads it (or loads from Firestore), calls `_resolve_email_template` → `get_template_instructions()` → `template_instructions` string. Calls `batch_generate_emails(..., template_instructions=..., email_template_purpose=...)`. Prompt = context + template_instructions + requirements_block. **requirements_block** still contains the fixed "SIGNATURE (exactly this format): Best, [Full Name] [University] | Class of [Year]".
4. **LLM** returns body text including a closing. Post-processing may insert resume line before "Best," / "Thanks," etc.
5. **emails.py** (generate-and-draft) may append its own signature block (again "Best," + name + university + email) if it doesn’t detect one.

---

## Step 3: Implementation Plan for Signoff Personalization

### Goal

Allow users to:

1. Choose a **signoff phrase** (e.g. "Best,", "Warm regards,", "Thanks,", "Cheers,", or custom).
2. Customize **signature block** (name, title/year, university, phone, LinkedIn).
3. **Preview** the signoff.
4. **Save** so it applies to all future generated emails.

---

### Data model changes

**Firestore `users/{uid}`:**

- Add a sub-map or top-level fields for signoff/signature. Recommended: one object for clarity.
- **Option A — single object:**
  - `emailSignoff`: {
    - `signoffPhrase`: string (e.g. "Best,", "Warm regards,", "Thanks,", "Cheers,", or custom text; default `"Best,"`)
    - `signatureName`: string | null (display name; null = use auth/profile name)
    - `signatureTitle`: string | null (e.g. "Class of 2025")
    - `signatureUniversity`: string | null
    - `signatureEmail`: boolean (include email in signature; default true if user has email)
    - `signaturePhone`: boolean (default false)
    - `signatureLinkedIn`: boolean (default false)
    - `customSignatureLine`: string | null (optional single line, e.g. "MBA Candidate 2025")
  }
- **Option B — keep flat:** Add `signoffPhrase`, `signatureUniversity`, etc. under `users/{uid}` or under `emailTemplate`. Option B is simpler; Option A keeps signoff grouped.

**Recommendation:** Extend `emailTemplate` so signoff lives next to purpose/style:

- `emailTemplate.signoffPhrase`: string (default `"Best,"`)
- `emailTemplate.signatureIncludeName`: boolean (default true)
- `emailTemplate.signatureUniversity`: string | null
- `emailTemplate.signatureYear`: string | null (e.g. "2025")
- `emailTemplate.signatureIncludeEmail`: boolean (default true)
- `emailTemplate.signatureIncludePhone`: boolean (default false)
- `emailTemplate.signatureIncludeLinkedIn`: boolean (default false)
- `emailTemplate.customSignatureLine`: string | null

Backward compatibility: if these are missing, treat as defaults (e.g. "Best,", include name/university/year from profile).

---

### Backend changes

1. **`backend/app/routes/email_template.py`**
   - **GET /api/email-template:** Return new signoff/signature fields (with defaults) in the JSON.
   - **POST /api/email-template:** Accept and validate new fields (signoffPhrase length, allowed values or free text), then `user_ref.set({"emailTemplate": { ... existing, ... new_fields }}, merge=True)`.

2. **`backend/email_templates.py`**
   - Add a helper, e.g. `get_signature_instructions(signoff_phrase, signature_opts)`, that returns a short prompt snippet like: "Close with exactly: {signoff_phrase} then sender name, then [University] | Class of [Year] if provided. Include email/phone/LinkedIn in signature only if requested."  
   - Optional: keep `get_template_instructions()` as-is and inject signature instructions in reply_generation instead (see below).

3. **`backend/app/services/reply_generation.py`**
   - **Where the signature is hardcoded:** In the non–custom branch, the `requirements_block` currently says:
     - `SIGNATURE (exactly this format):\nBest,\n[Full Name]\n[University] | Class of [Year]`
   - **Change:** Accept optional signoff/signature config (from caller). Build the SIGNATURE section dynamically:
     - If no signoff config: keep current "Best," + [Full Name] + [University] | Class of [Year].
     - If signoff config: use `signoffPhrase`, then name, then optional university/year line, then optional email/phone/LinkedIn from user_profile.
   - **Callers:** `batch_generate_emails(..., signoff_phrase=None, signature_opts=None)`. When None, use current behavior.
   - **Resume line insertion:** Continue to look for sign-off patterns; add the user’s `signoffPhrase` to `sign_off_patterns` so the resume line is inserted before the user’s chosen phrase.
   - **Fallback emails:** Use `signoff_phrase` and signature opts when building the fallback body closing.

4. **`backend/app/routes/runs.py`**
   - In `_resolve_email_template`, also load signoff/signature fields from Firestore `emailTemplate` and return them (or pass through to a new helper that returns template_instructions + signoff_config).
   - When calling `batch_generate_emails`, pass `signoff_phrase` and `signature_opts` (from request or Firestore).

5. **`backend/app/routes/emails.py` (generate-and-draft)**
   - **Important:** This route currently does not load the user’s email template. Add:
     - Read `users/{uid}.emailTemplate` (or at least signoff/signature fields).
     - Resolve `template_instructions` and `email_template_purpose` the same way as runs (so Discover Contacts respects saved template and signoff).
     - Call `batch_generate_emails(..., template_instructions=..., email_template_purpose=..., signoff_phrase=..., signature_opts=...)`.
   - When **appending** a signature in emails.py because the body has none, use the user’s `signoffPhrase` and signature opts instead of hardcoded "Best," and the same name/university/year/email/phone/LinkedIn logic.

---

### Frontend changes

1. **`connect-grow-hire/src/services/api.ts`**
   - Extend `EmailTemplate` (or add `EmailSignoff` type) with: `signoffPhrase`, `signatureIncludeName`, `signatureUniversity`, `signatureYear`, `signatureIncludeEmail`, `signatureIncludePhone`, `signatureIncludeLinkedIn`, `customSignatureLine`.
   - Ensure GET/POST payloads for email template include these.

2. **`connect-grow-hire/src/pages/EmailTemplatesPage.tsx`**
   - Add a **“Sign-off & signature”** section:
     - **Signoff phrase:** Dropdown or short input: "Best,", "Warm regards,", "Thanks,", "Cheers,", "Sincerely,", "Custom" (with text input). Default "Best,".
     - **Signature block:**
       - Checkbox: Include name (default on).
       - Optional fields: University, Year (e.g. Class of 2025), or a single “Custom line” (e.g. "MBA Candidate 2025").
       - Checkboxes: Include email, Include phone, Include LinkedIn (defaults: email on, phone/LinkedIn off, or per your product choice).
   - **Preview:** A small box showing 2–3 lines: chosen signoff phrase, then name, then university/year and contact lines as configured (e.g. "Best,\nJane Doe\nUSC | Class of 2025\njane@example.com").
   - On Save, send the new fields in the same POST used for purpose/style/customInstructions.

3. **`connect-grow-hire/src/components/EmailTemplateModal.tsx`**
   - Add the same signoff phrase + signature block controls and preview (can be collapsed “Sign-off & signature” section to avoid clutter).
   - `buildTemplate()` should include the new fields so “Apply” and “Save as default” persist them.

4. **ContactSearchPage (optional)**
   - If you want generate-and-draft to use the saved template (including signoff), no extra UI is required once the backend loads and uses `emailTemplate` for that route. The “Email template” link already takes users to EmailTemplatesPage to set defaults.

---

### Edge cases & behavior

1. **No signoff set (new users / migration):** If `signoffPhrase` (and optional fields) are missing, backend uses current default: "Best," + full name + university | Class of year. No migration script required if you treat missing as default.
2. **Different style_preset:** Style presets only hint at tone (e.g. “Sign off with Thanks,”). The **structural** signoff (phrase + name + optional lines) should come from the new signoff/signature settings so they apply consistently regardless of style.
3. **Custom purpose:** For purpose "custom", the user’s custom instructions can still say “Sign off with …”. The new signoff/signature block can either override that for the final line (recommended for consistency) or be combined; recommend override so one place controls the actual closing.
4. **Preview:** Preview can use the same logic as backend (e.g. a small helper that builds 2–3 lines from signoffPhrase + name + university/year + contact flags). Name in preview can come from `user.displayName` or profile.
5. **Resume line:** Always insert “I've attached my resume below” (or equivalent) **before** the user’s chosen signoff phrase, not after, so the order remains: body → resume line → signoff phrase → signature block.

---

### Numbered list of concrete code changes

1. **Firestore / API contract:** Define and document the new `emailTemplate` fields (signoffPhrase, signatureIncludeName, signatureUniversity, signatureYear, signatureIncludeEmail, signatureIncludePhone, signatureIncludeLinkedIn, customSignatureLine) in `backend/app/routes/email_template.py` (GET/POST) and validate on POST.
2. **email_template.py:** In GET, return the new fields with defaults. In POST, accept and merge them into `emailTemplate`.
3. **api.ts:** Extend `EmailTemplate` type and ensure get/save send the new fields.
4. **reply_generation.py:** Add optional `signoff_phrase` and `signature_opts` to `batch_generate_emails`. Build the SIGNATURE section of `requirements_block` from these when provided; otherwise keep current "Best," format. Add user’s signoff phrase to `sign_off_patterns` for resume-line insertion. Use in fallback email body.
5. **runs.py:** In `_resolve_email_template` (or when building args for `batch_generate_emails`), read signoff/signature from Firestore `emailTemplate` and pass into `batch_generate_emails`.
6. **emails.py:** In `generate_and_draft`, load `users/{uid}.emailTemplate`, resolve `template_instructions` and `email_template_purpose` (reuse same logic as runs), and pass `template_instructions`, `email_template_purpose`, `signoff_phrase`, and `signature_opts` into `batch_generate_emails`. When appending signature, use signoff phrase and signature opts instead of hardcoded "Best,".
7. **EmailTemplatesPage.tsx:** Add “Sign-off & signature” section (signoff dropdown/input, signature checkboxes/inputs, preview), and include new fields in `buildTemplate()` and save request.
8. **EmailTemplateModal.tsx:** Add same signoff/signature section and wire into `buildTemplate()`.
9. **Optional:** Add `get_signature_instructions()` or similar in `email_templates.py` if you want to inject signature rules into the prompt text; otherwise implementing the dynamic SIGNATURE block in reply_generation is enough.

This gives a single, consistent place (email template + signoff/signature) that applies to both Discover Contacts and run-based flows, with clear defaults and preview.
