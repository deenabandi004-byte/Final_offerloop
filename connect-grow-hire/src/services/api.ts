// src/services/api.ts
const API_BASE_URL =
  import.meta.env.VITE_API_BASE_URL ||
  (['localhost', '127.0.0.1', '0.0.0.0'].includes(window.location.hostname)
    ? 'http://localhost:5001/api'
    : 'https://www.offerloop.ai/api');

export interface UserProfile {
  name?: string;
  university?: string;
  major?: string;
  year?: string;
  graduationYear?: string;
  degree?: string;
  careerInterests?: string[];
}

export interface ContactSearchRequest {
  jobTitle: string;
  company: string;
  location: string;
  uid?: string;
  saveToDirectory?: boolean;
  userProfile?: UserProfile | null;
  careerInterests?: string[];
  collegeAlumni?: string; // ✅ NEW: Added collegeAlumni field
  batchSize?: number;
}

export interface ProContactSearchRequest extends ContactSearchRequest {
  resume: File;
}

export interface Contact {
  FirstName: string;
  LastName: string;
  LinkedIn: string;
  Email: string;
  Title: string;
  Company: string;
  City: string;
  State: string;
  College: string;
  Phone?: string;
  PersonalEmail?: string;
  WorkEmail?: string;
  SocialProfiles?: string;
  EducationTop?: string;
  VolunteerHistory?: string;
  WorkSummary?: string;
  Group?: string;
  Hometown?: string;
  Similarity?: string;
  email_subject?: string; // Email subject generated by backend
  email_body?: string; // Email body generated by backend
}

// Base response type
export interface SearchResponse {
  contacts: Contact[];
  successful_drafts: number;
  total_contacts: number;
  tier: string;
  user_email: string;
  credits_used?: number;
  credits_remaining?: number;
}

// Error response type
export interface ErrorResponse {
  error: string;
  current_credits?: number;
  credits_needed?: number;
}
// ================================
// NEW: Bell Notification Types
// ================================
export interface ReplyStatus {
  hasReply: boolean;
  isUnread: boolean;
  messageId?: string;
  muted?: boolean;
}

export interface GenerateReplyResult {
  success: boolean;
  draftId: string;
  threadId: string;
  gmailUrl: string;
}

// ================================
// Outbox Types
// ================================
export type OutboxStatus =
  | "no_reply_yet"
  | "new_reply"
  | "waiting_on_them"
  | "waiting_on_you"
  | "closed";

export interface OutboxThread {
  id: string;
  contactName: string;
  jobTitle: string;
  company: string;
  email: string;
  status: OutboxStatus;
  lastMessageSnippet: string;
  lastActivityAt: string; // ISO string
  hasDraft: boolean;
  suggestedReply?: string;
  gmailDraftUrl?: string;
  replyType?: "positive" | "referral" | "delay" | "decline" | "question";
}

export interface OutboxThreadsResponse {
  threads: OutboxThread[];
}

export interface RegenerateReplyResponse {
  thread: OutboxThread;
  success: boolean;
  message?: string;
}

// Union type for search results
export type SearchResult = SearchResponse | ErrorResponse;

// Helper type guard
export function isErrorResponse(result: SearchResult): result is ErrorResponse {
  return 'error' in result && typeof result.error === 'string';
}

export interface FreeSearchResponse extends SearchResponse {}
export interface ProSearchResponse extends SearchResponse {}

export interface ApiError {
  error: string;
}

// ================================
// Coffee Chat Prep Types
// ================================
export interface CoffeeChatPrepRequest {
  linkedinUrl: string;
  resumeText?: string;
}

export interface CoffeeChatPrepResponse {
  prepId: string;
  status: string;
  message: string;
}

export interface CoffeeChatNewsItem {
  title: string;
  url: string;
  source: string;
  published_at?: string;
  summary: string;
  relevance_tag: 'division' | 'office' | 'industry';
  confidence?: string;
}

export interface CoffeeChatPrepStatus {
  id?: string;  // ✅ ADD THIS - backend uses 'id'
  prepId?: string;  // Keep for backwards compatibility
  status:
    | 'pending'
    | 'processing'
    | 'enriching_profile'
    | 'fetching_news'
    | 'extracting_hometown'
    | 'generating_content'
    | 'completed'
    | 'failed';
  contactData?: any;
  companyNews?: CoffeeChatNewsItem[];
  similaritySummary?: string;
  coffeeQuestions?: string[];
  pdfUrl?: string;
  pdfStoragePath?: string;
  industrySummary?: string;
  hometown?: string | null;
  context?: Record<string, any>;
  error?: string;
  completedAt?: string;  // ✅ ADD THIS
  createdAt?: string;  // ✅ ADD THIS
  linkedinUrl?: string;  // ✅ ADD THIS
  userId?: string;  // ✅ ADD THIS
  userEmail?: string;  // ✅ ADD THIS
}

export interface CoffeeChatPrep {
  id: string;
  contactName: string;
  company: string;
  jobTitle: string;
  linkedinUrl?: string;
  status: string;
  createdAt: string;
  pdfUrl?: string;
  error?: string;
  industrySummary?: string;
  hometown?: string | null;
}

// ================================
// Interview Prep Types
// ================================
export interface InterviewPrepRequest {
  job_posting_url?: string;
  company_name?: string;
  job_title?: string;
}

export interface InterviewPrepResponse {
  id: string;
  status: string;
}

export interface InterviewPrepStatus {
  id?: string;
  status:
    | 'pending'
    | 'processing'
    | 'parsing_job_posting'
    | 'parsing_failed'
    | 'extracting_requirements'
    | 'scraping_reddit'
    | 'processing_content'
    | 'generating_pdf'
    | 'completed'
    | 'failed';
  needsManualInput?: boolean;
  progress?: string;
  jobDetails?: {
    company_name: string;
    company_domain: string;
    job_title: string;
    level?: string;
    team_division?: string;
    location?: string;
    remote_policy?: string;
    required_skills?: string[];
    preferred_skills?: string[];
    years_experience?: string;
    job_type?: string;
    key_responsibilities?: string[];
    interview_hints?: string;
    salary_range?: string;
    role_category?: string;
  };
  insights?: {
    company_name: string;
    last_updated: string;
    interview_process?: {
      stages: string[];
      timeline: string;
      format: string;
      interviewers?: string;
      duration?: string;
      pass_rates?: string;
    };
    common_questions?: Array<{
      category: string;
      questions: string[];
      tips?: string;
    }>;
    real_interview_experiences?: Array<{
      role: string;
      year: string;
      summary: string;
      surprising?: string;
      difficulty?: string;
    }>;
    success_tips?: {
      preparation?: string[];
      during_interview?: string[];
      company_specific?: string[];
    };
    red_flags_and_mistakes?: string[];
    day_of_logistics?: {
      what_to_wear?: string;
      arrival_time?: string;
      what_to_bring?: string;
      virtual_setup?: string;
      parking_building_access?: string;
    };
    post_interview?: {
      response_timeline?: string;
      thank_you_notes?: string;
      follow_up?: string;
      offer_details?: string;
      negotiation_tips?: string;
    };
    culture_insights?: {
      work_life_balance?: string;
      team_dynamics?: string;
      management_style?: string;
      growth_opportunities?: string;
      diversity_inclusion?: string;
      remote_policy?: string;
    };
    compensation?: {
      base_salary_range?: string;
      bonus_structure?: string;
      benefits_highlights?: string;
      salary_by_level?: string;
      negotiation_room?: string;
    };
    role_specific_prep?: {
      prep_topics?: string[];
      practice_resources?: string[];
      time_investment?: string;
    };
    sources_count?: number;
    sources_summary?: string;
  };
  pdfUrl?: string;
  pdfStoragePath?: string;
  error?: string;
  completedAt?: string;
  createdAt?: string;
  userId?: string;
  userEmail?: string;
}

export interface InterviewPrep {
  id: string;
  companyName: string;
  jobTitle?: string;
  status: string;
  createdAt: string;
  pdfUrl?: string;
  error?: string;
}

// ================================
// ApiService
// ================================
class ApiService {
  // ---- Auth helpers ----
  private async getIdToken(): Promise<string> {
    try {
      const { auth } = await import('../lib/firebase');
      if (!auth.currentUser) {
        throw new Error('User not authenticated');
      }
      return await auth.currentUser.getIdToken();
    } catch (error) {
      console.error('Error getting Firebase auth token:', error);
      throw new Error('Authentication required. Please sign in again.');
    }
  }

  private async getAuthHeaders(): Promise<Record<string, string>> {
    const headers: Record<string, string> = { 'Content-Type': 'application/json' };

    try {
      const token = await this.getIdToken();
      headers['Authorization'] = `Bearer ${token}`;
    } catch (error) {
      console.error('Error getting Firebase auth headers:', error);
      throw error;
    }

    return headers;
  }

  // ---- Request helper ----
  private async makeRequest<T>(endpoint: string, options: RequestInit = {}): Promise<T> {
  const url = `${API_BASE_URL}${endpoint}`;

  console.log(`Making request to: ${url}`);
  console.log(`Request options:`, options);

  const response = await fetch(url, options);
  console.log(`Response status: ${response.status}`);

  // Check for binary/attachments first (read only once)
  const ct = response.headers.get('content-type') || '';
  const cd = response.headers.get('content-disposition') || '';
  if (ct.includes('text/csv') || ct.includes('application/pdf') || cd.includes('attachment')) {
    const blob = await response.blob();
    if (!response.ok) throw new Error(`HTTP ${response.status}: ${response.statusText}`);
    return blob as unknown as T;
  }

  // For JSON/text responses, read once
  const bodyText = await response.text();
  let data: any = {};
  if (bodyText) {
    try { data = JSON.parse(bodyText); }
    catch { data = { raw: bodyText }; }
  }

  if (!response.ok) {
    // For 401 with needsAuth, preserve the full error data including authUrl
    if (response.status === 401 && data && (data.needsAuth || data.require_reauth)) {
      const error: any = new Error(data.message || data.error || 'Authentication required');
      error.needsAuth = data.needsAuth || data.require_reauth;
      error.authUrl = data.authUrl;
      error.contacts = data.contacts;
      error.status = 401;
      throw error;
    }
    
    const message =
      (data && (data.error || data.message || data.detail)) ||
      `HTTP ${response.status}: ${response.statusText}`;
    throw new Error(message);
  }

  return (data as T) ?? ({} as T);
}


  // ================================
  // Contact Search Endpoints
  // ================================

  /**
   * Free tier search - returns JSON with contacts and email data
   * Contacts are automatically saved to Contact Library on frontend
   */
  async runFreeSearch(request: ContactSearchRequest): Promise<SearchResult> {
    const headers = await this.getAuthHeaders();

    const backendRequest = {
      jobTitle: request.jobTitle,
      company: request.company,
      location: request.location,
      saveToDirectory: false, // Always false since we handle saving on frontend
      userProfile: request.userProfile,
      careerInterests: request.careerInterests || [],
      collegeAlumni: request.collegeAlumni || '', // ✅ Include collegeAlumni
      batchSize: request.batchSize, // ✅ Include batch size
    };

    console.log(`Free Search Request:`, backendRequest);

    return this.makeRequest<SearchResult>('/free-run', {
      method: 'POST',
      headers,
      body: JSON.stringify(backendRequest),
    });
  }

  /**
   * Pro tier search - returns JSON with contacts and email data
   * Contacts are automatically saved to Contact Library on frontend
   */
  async runProSearch(request: ProContactSearchRequest): Promise<SearchResult> {
    const idToken = await this.getIdToken();

    const formData = new FormData();
    formData.append('jobTitle', request.jobTitle);
    formData.append('company', request.company);
    formData.append('location', request.location);
    formData.append('resume', request.resume);
    formData.append('saveToDirectory', 'false'); // Always false since we handle saving on frontend
    formData.append('collegeAlumni', request.collegeAlumni || ''); // ✅ Include collegeAlumni

    if (request.userProfile) {
      formData.append('userProfile', JSON.stringify(request.userProfile));
    }

    if (request.careerInterests && request.careerInterests.length > 0) {
      formData.append('careerInterests', JSON.stringify(request.careerInterests));
    }

    console.log(`Pro Search Request - FormData contents:`);
    console.log(`  jobTitle: "${request.jobTitle}"`);
    console.log(`  company: "${request.company}"`);
    console.log(`  location: "${request.location}"`);
    console.log(`  resume: ${request.resume.name} (${request.resume.size} bytes)`);
    console.log(`  userProfile: ${JSON.stringify(request.userProfile)}`);
    console.log(`  careerInterests: ${JSON.stringify(request.careerInterests)}`);
    console.log(`  collegeAlumni: "${request.collegeAlumni || ''}"`);

    return this.makeRequest<SearchResult>('/pro-run', {
      method: 'POST',
      headers: {
        Authorization: `Bearer ${idToken}`,
        // Do not set Content-Type for FormData - the browser will set proper boundary
      },
      body: formData,
    });
  }

  /**
   * Optional CSV download for Free tier
   */
  async runFreeSearchCsv(request: ContactSearchRequest): Promise<Blob> {
    const headers = await this.getAuthHeaders();

    const backendRequest = {
      jobTitle: request.jobTitle,
      company: request.company,
      location: request.location,
      saveToDirectory: false,
      userProfile: request.userProfile,
      careerInterests: request.careerInterests || [],
      collegeAlumni: request.collegeAlumni || '',
    };

    return this.makeRequest<Blob>('/free-run-csv', {
      method: 'POST',
      headers,
      body: JSON.stringify(backendRequest),
    });
  }

  /**
   * Optional CSV download for Pro tier
   */
  async runProSearchCsv(request: ProContactSearchRequest): Promise<Blob> {
    const idToken = await this.getIdToken();

    const formData = new FormData();
    formData.append('jobTitle', request.jobTitle);
    formData.append('company', request.company);
    formData.append('location', request.location);
    formData.append('resume', request.resume);
    formData.append('saveToDirectory', 'false');
    formData.append('collegeAlumni', request.collegeAlumni || '');

    if (request.userProfile) {
      formData.append('userProfile', JSON.stringify(request.userProfile));
    }

    if (request.careerInterests && request.careerInterests.length > 0) {
      formData.append('careerInterests', JSON.stringify(request.careerInterests));
    }

    return this.makeRequest<Blob>('/pro-run-csv', {
      method: 'POST',
      headers: {
        Authorization: `Bearer ${idToken}`,
      },
      body: formData,
    });
  }

  // ---- Deprecated shims ----
  /** @deprecated Use runFreeSearch() instead. */
  async runBasicSearch(request: ContactSearchRequest): Promise<SearchResult> {
    console.warn('runBasicSearch is deprecated. Use runFreeSearch() instead.');
    return this.runFreeSearch(request);
  }

  /** @deprecated Advanced tier removed. Use runFreeSearch() or runProSearch(). */
  async runAdvancedSearch(request: ContactSearchRequest): Promise<SearchResult> {
    console.warn('runAdvancedSearch is deprecated. Redirecting to Free tier.');
    return this.runFreeSearch(request);
  }

  // ================================
  // Coffee Chat Prep Endpoints
  // ================================

  /** Create a Coffee Chat Prep */
  async createCoffeeChatPrep(request: CoffeeChatPrepRequest): Promise<CoffeeChatPrepResponse | ApiError> {
    const headers = await this.getAuthHeaders();
    return this.makeRequest<CoffeeChatPrepResponse | ApiError>('/coffee-chat-prep', {
      method: 'POST',
      headers,
      body: JSON.stringify(request),
    });
  }

  /** Get Coffee Chat Prep status */
  async getCoffeeChatPrepStatus(prepId: string): Promise<CoffeeChatPrepStatus | ApiError> {
    const headers = await this.getAuthHeaders();
    return this.makeRequest<CoffeeChatPrepStatus | ApiError>(`/coffee-chat-prep/${prepId}`, {
      method: 'GET',
      headers,
    });
  }

  /** Get Coffee Chat PDF download URL */
  async downloadCoffeeChatPDF(prepId: string): Promise<{ pdfUrl: string }> {
    const headers = await this.getAuthHeaders();
    return this.makeRequest<{ pdfUrl: string }>(`/coffee-chat-prep/${prepId}/download`, {
      method: 'GET',
      headers,
    });
  }

  /** Get all Coffee Chat Preps for user */
  async getAllCoffeeChatPreps(): Promise<{ preps: CoffeeChatPrep[] } | ApiError> {
    const headers = await this.getAuthHeaders();
    return this.makeRequest<{ preps: CoffeeChatPrep[] } | ApiError>('/coffee-chat-prep/all', {
      method: 'GET',
      headers,
    });
  }

  /** Get Coffee Chat history (limited) */
  async getCoffeeChatHistory(limit: number = 10): Promise<{ history: CoffeeChatPrep[] } | ApiError> {
    const headers = await this.getAuthHeaders();
    return this.makeRequest<{ history: CoffeeChatPrep[] } | ApiError>(`/coffee-chat-prep/history?limit=${limit}`, {
      method: 'GET',
      headers,
    });
  }

  // ================================
  // Interview Prep Endpoints
  // ================================
  async generateInterviewPrep(request: InterviewPrepRequest): Promise<InterviewPrepResponse | ApiError> {
    const headers = await this.getAuthHeaders();
    return this.makeRequest<InterviewPrepResponse | ApiError>('/interview-prep/generate', {
      method: 'POST',
      headers,
      body: JSON.stringify(request),
    });
  }

  async getInterviewPrepStatus(prepId: string): Promise<InterviewPrepStatus | ApiError> {
    const headers = await this.getAuthHeaders();
    return this.makeRequest<InterviewPrepStatus | ApiError>(`/interview-prep/status/${prepId}`, {
      method: 'GET',
      headers,
    });
  }

  async downloadInterviewPrepPDF(prepId: string): Promise<{ pdfUrl: string }> {
    const headers = await this.getAuthHeaders();
    return this.makeRequest<{ pdfUrl: string }>(`/interview-prep/download/${prepId}`, {
      method: 'GET',
      headers,
    });
  }

  async getInterviewPrepHistory(limit: number = 10): Promise<{ history: InterviewPrep[] } | ApiError> {
    const headers = await this.getAuthHeaders();
    return this.makeRequest<{ history: InterviewPrep[] } | ApiError>(`/interview-prep/history?limit=${limit}`, {
      method: 'GET',
      headers,
    });
  }

    // ================================
  // Gmail Integration Endpoints
  // ================================
  async startGmailOAuth(): Promise<string> {
    const headers = await this.getAuthHeaders();
    const { authUrl } = await this.makeRequest<{ authUrl: string }>(
      '/google/oauth/start',
      { headers }
    );
    return authUrl;
  }

  async gmailStatus(): Promise<{ connected: boolean; scopes: string[] }> {
    const headers = await this.getAuthHeaders();
    return this.makeRequest<{ connected: boolean; scopes: string[] }>(
      '/google/gmail/status',
      { headers }
    );
  }

  async saveGmailDraft(params: {
    to?: string; subject?: string; body?: string; threadId?: string;
  }): Promise<{ ok: boolean; draftId: string; messageId?: string; threadId?: string } | ApiError> {
    const headers = await this.getAuthHeaders();
    return this.makeRequest('/gmail/drafts', {
      method: 'POST',
      headers,
      body: JSON.stringify(params),
    });
  }

  // ================================
  // Misc
  // ================================

  /** Get tier information from backend */
  async getTierInfo(): Promise<{
    tiers: {
      free: {
        name: string;
        max_contacts: number;
        credits: number;
        time_saved_minutes: number;
        description: string;
        features: string[];
      };
      pro: {
        name: string;
        max_contacts: number;
        credits: number;
        time_saved_minutes: number;
        description: string;
        features: string[];
      };
    };
  }> {
    const headers = await this.getAuthHeaders();
    return this.makeRequest('/tier-info', { headers });
  }

  /** Check credits */
  async checkCredits(): Promise<{ credits: number; max_credits: number; searches_remaining: number }> {
    const headers = await this.getAuthHeaders();
    return this.makeRequest('/check-credits', { headers });
  }

  /** Health check */
  async checkHealth(): Promise<{ status: string; tiers: string[]; services: Record<string, string> }> {
    return this.makeRequest('/health');
  }
  
  /** Delete Coffee Chat Prep */
  async deleteCoffeeChatPrep(prepId: string): Promise<{ success: boolean; message: string } | ApiError> {
    const headers = await this.getAuthHeaders();
    return this.makeRequest<{ success: boolean; message: string } | ApiError>(`/coffee-chat-prep/${prepId}`, {
      method: 'DELETE',
      headers,
    });
  }
  
// ================================
// NEW: Bell Notification Endpoints
// ================================

/** Check if a contact has replied to our email */
async checkContactReplies(contactId: string): Promise<ReplyStatus | ErrorResponse> {
  const headers = await this.getAuthHeaders();
  return this.makeRequest<ReplyStatus | ErrorResponse>(`/contacts/${contactId}/check-replies`, {
    method: 'GET',
    headers,
  });
}

/** Batch check replies for multiple contacts */
async batchCheckReplies(contactIds: string[]): Promise<{ results: Record<string, ReplyStatus> } | ErrorResponse> {
  const headers = await this.getAuthHeaders();
  return this.makeRequest<{ results: Record<string, ReplyStatus> } | ErrorResponse>(
    '/contacts/batch-check-replies',
    {
      method: 'POST',
      headers,
      body: JSON.stringify({ contactIds }),
    }
  );
}

/** Mute/unmute notifications for a contact */
async muteContactNotifications(contactId: string, muted: boolean): Promise<{ success: boolean; muted: boolean } | ErrorResponse> {
  const headers = await this.getAuthHeaders();
  return this.makeRequest<{ success: boolean; muted: boolean } | ErrorResponse>(
    `/contacts/${contactId}/mute-notifications`,
    {
      method: 'POST',
      headers,
      body: JSON.stringify({ muted }),
    }
  );
}

/** Generate a reply draft for a contact's message */
async generateReplyDraft(contactId: string): Promise<GenerateReplyResult | ErrorResponse> {
  const headers = await this.getAuthHeaders();
  return this.makeRequest<GenerateReplyResult | ErrorResponse>(`/contacts/${contactId}/generate-reply`, {
    method: 'POST',
    headers,
  });
}


  // ================================
  // Outbox API
  // ================================
  
  /** Get all outbox email threads */
  // ================================
// Outbox API
// ================================

/** Get all Outbox email threads */
async getOutboxThreads(): Promise<{ threads: OutboxThread[] } | { error: string }> {
  const headers = await this.getAuthHeaders();

  return this.makeRequest<{ threads: OutboxThread[] } | { error: string }>(
    '/outbox/threads',
    {
      method: 'GET',
      headers
    }
  );
}

/** Regenerate a suggested reply + Gmail draft for a thread */
async regenerateOutboxReply(
  threadId: string
): Promise<{ thread: OutboxThread } | { error: string }> {
  const headers = await this.getAuthHeaders();

  return this.makeRequest<{ thread: OutboxThread } | { error: string }>(
    `/outbox/threads/${threadId}/regenerate`,
    {
      method: 'POST',
      headers,
      body: JSON.stringify({})
    }
  );
}



  /** Helper to download CSV blob as file */
  downloadCsv(blob: Blob, filename: string = 'contacts.csv') {
    const url = window.URL.createObjectURL(blob);
    const link = document.createElement('a');
    link.href = url;
    link.download = filename;
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    window.URL.revokeObjectURL(url);
  }
}

export const apiService = new ApiService();
export default apiService;