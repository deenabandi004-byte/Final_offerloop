// src/services/api.ts
const API_BASE_URL =
  import.meta.env.VITE_API_BASE_URL ||
  (['localhost', '127.0.0.1', '0.0.0.0'].includes(window.location.hostname)
    ? 'http://localhost:5001/api'
    : 'https://www.offerloop.ai/api');

export interface UserProfile {
  name?: string;
  university?: string;
  major?: string;
  year?: string;
  graduationYear?: string;
  degree?: string;
  careerInterests?: string[];
}

export interface ContactSearchRequest {
  jobTitle: string;
  company?: string; // Optional - company is not required for contact search
  location: string;
  uid?: string;
  saveToDirectory?: boolean;
  userProfile?: UserProfile | null;
  careerInterests?: string[];
  collegeAlumni?: string; // ‚úÖ NEW: Added collegeAlumni field
  batchSize?: number;
}

export interface ProContactSearchRequest extends ContactSearchRequest {
  resume: File;
}

// ================================
// Prompt Search Types (Experimental)
// ================================
export interface ParsedSearchFilters {
  company: string[];
  roles: string[];
  location: string[];
  schools: string[];
  industries: string[];
  max_results: number;
  confidence: number;
}

// Simple prompt search response
export interface PromptSearchResponse {
  contacts: Contact[];
  parsed_query: {
    job_title: string;
    company: string;
    location: string;
    school: string;
  };
  count: number;
}

export interface Contact {
  FirstName: string;
  LastName: string;
  LinkedIn: string;
  Email: string;
  Title: string;
  Company: string;
  City: string;
  State: string;
  College: string;
  Phone?: string;
  PersonalEmail?: string;
  WorkEmail?: string;
  SocialProfiles?: string;
  EducationTop?: string;
  VolunteerHistory?: string;
  WorkSummary?: string;
  Group?: string;
  Hometown?: string;
  Similarity?: string;
  email_subject?: string; // Email subject generated by backend
  email_body?: string; // Email body generated by backend
}

// Recruiter interface (extends Contact but specific to recruiters)
export interface Recruiter {
  FirstName: string;
  LastName: string;
  Email: string;
  LinkedIn: string;
  Title: string;
  Company: string;
  City: string;
  State: string;
  Phone?: string;
  WorkEmail?: string;
  PersonalEmail?: string;
}

export interface FindRecruiterRequest {
  company?: string;  // Optional - can be extracted from jobUrl or jobDescription
  jobTitle?: string;
  jobDescription?: string;
  jobType?: 'engineering' | 'sales' | 'marketing' | 'finance' | 'intern' | 'general';
  location?: string;
  jobUrl?: string;  // Optional - for external job links
  generateEmails?: boolean;  // Default true - generate personalized emails
  createDrafts?: boolean;  // Default true - create Gmail drafts
}

export interface RecruiterEmail {
  recruiter: Recruiter;
  to_email: string;
  to_name: string;
  subject: string;
  body: string;  // HTML version
  plain_body: string;  // Plain text version
  approach_used: string;
}

export interface DraftCreated {
  recruiter_email: string;
  draft_id: string;
  draft_url: string;
}

export interface FindRecruiterResponse {
  recruiters: Recruiter[];
  emails?: RecruiterEmail[];
  draftsCreated?: DraftCreated[];
  jobTypeDetected: string;
  companyCleaned: string;
  searchTitles: string[];
  totalFound: number;
  creditsCharged: number;
  creditsRemaining: number;
  hasMore?: boolean;
  moreAvailable?: number;
  creditsNeededForMore?: number;
  message?: string;
  error?: string;
}

// Base response type
export interface SearchResponse {
  contacts: Contact[];
  successful_drafts: number;
  total_contacts: number;
  tier: string;
  user_email: string;
  credits_used?: number;
  credits_remaining?: number;
}

// Error response type
export interface ErrorResponse {
  error: string;
  current_credits?: number;
  credits_needed?: number;
}
// ================================
// NEW: Bell Notification Types
// ================================
export interface ReplyStatus {
  hasReply: boolean;
  isUnread: boolean;
  messageId?: string;
  muted?: boolean;
}

export interface GenerateReplyResult {
  success: boolean;
  draftId: string;
  threadId: string;
  gmailUrl: string;
}

// ================================
// Outbox Types
// ================================
export type OutboxStatus =
  | "no_reply_yet"
  | "new_reply"
  | "waiting_on_them"
  | "waiting_on_you"
  | "closed";

export interface OutboxThread {
  id: string;
  contactName: string;
  jobTitle: string;
  company: string;
  email: string;
  status: OutboxStatus;
  lastMessageSnippet: string;
  lastActivityAt: string; // ISO string
  hasDraft: boolean;
  suggestedReply?: string;
  gmailDraftUrl?: string;
  gmailDraftId?: string;
  replyType?: "positive" | "referral" | "delay" | "decline" | "question";
}

export interface OutboxThreadsResponse {
  threads: OutboxThread[];
}

export interface RegenerateReplyResponse {
  thread: OutboxThread;
  success: boolean;
  message?: string;
}

// Union type for search results
export type SearchResult = SearchResponse | ErrorResponse;

// Helper type guard
export function isErrorResponse(result: SearchResult): result is ErrorResponse {
  return 'error' in result && typeof result.error === 'string';
}

export interface FreeSearchResponse extends SearchResponse {}
export interface ProSearchResponse extends SearchResponse {}

export interface ApiError {
  error: string;
}

// ================================
// Coffee Chat Prep Types
// ================================
export interface CoffeeChatPrepRequest {
  linkedinUrl: string;
  resumeText?: string;
}

export interface CoffeeChatPrepResponse {
  prepId: string;
  status: string;
  message: string;
}

export interface CoffeeChatNewsItem {
  title: string;
  url: string;
  source: string;
  published_at?: string;
  summary: string;
  relevance_tag: 'division' | 'office' | 'industry';
  confidence?: string;
}

export interface CoffeeChatPrepStatus {
  id?: string;  // ‚úÖ ADD THIS - backend uses 'id'
  prepId?: string;  // Keep for backwards compatibility
  status:
    | 'pending'
    | 'processing'
    | 'enriching_profile'
    | 'fetching_news'
    | 'extracting_hometown'
    | 'generating_content'
    | 'completed'
    | 'failed';
  contactData?: any;
  companyNews?: CoffeeChatNewsItem[];
  similaritySummary?: string;
  coffeeQuestions?: string[];
  pdfUrl?: string;
  pdfStoragePath?: string;
  industrySummary?: string;
  hometown?: string | null;
  context?: Record<string, any>;
  error?: string;
  completedAt?: string;  // ‚úÖ ADD THIS
  createdAt?: string;  // ‚úÖ ADD THIS
  linkedinUrl?: string;  // ‚úÖ ADD THIS
  userId?: string;  // ‚úÖ ADD THIS
  userEmail?: string;  // ‚úÖ ADD THIS
}

export interface CoffeeChatPrep {
  id: string;
  contactName: string;
  company: string;
  jobTitle: string;
  linkedinUrl?: string;
  status: string;
  createdAt: string;
  pdfUrl?: string;
  error?: string;
  industrySummary?: string;
  hometown?: string | null;
}

// ================================
// Interview Prep Types
// ================================
export interface InterviewPrepRequest {
  job_posting_url?: string;
  company_name?: string;
  job_title?: string;
}

export interface InterviewPrepResponse {
  id: string;
  status: string;
}

export interface InterviewPrepStatus {
  id?: string;
  status:
    | 'pending'
    | 'processing'
    | 'parsing_job_posting'
    | 'parsing_failed'
    | 'extracting_requirements'
    | 'scraping_reddit'
    | 'processing_content'
    | 'generating_pdf'
    | 'completed'
    | 'failed';
  needsManualInput?: boolean;
  progress?: string;
  jobDetails?: {
    company_name: string;
    company_domain: string;
    job_title: string;
    level?: string;
    team_division?: string;
    location?: string;
    remote_policy?: string;
    required_skills?: string[];
    preferred_skills?: string[];
    years_experience?: string;
    job_type?: string;
    key_responsibilities?: string[];
    interview_hints?: string;
    salary_range?: string;
    role_category?: string;
  };
  insights?: {
    company_name: string;
    last_updated: string;
    interview_process?: {
      stages: string[];
      timeline: string;
      format: string;
      interviewers?: string;
      duration?: string;
      pass_rates?: string;
    };
    common_questions?: Array<{
      category: string;
      questions: string[];
      tips?: string;
    }>;
    real_interview_experiences?: Array<{
      role: string;
      year: string;
      summary: string;
      surprising?: string;
      difficulty?: string;
    }>;
    success_tips?: {
      preparation?: string[];
      during_interview?: string[];
      company_specific?: string[];
    };
    red_flags_and_mistakes?: string[];
    day_of_logistics?: {
      what_to_wear?: string;
      arrival_time?: string;
      what_to_bring?: string;
      virtual_setup?: string;
      parking_building_access?: string;
    };
    post_interview?: {
      response_timeline?: string;
      thank_you_notes?: string;
      follow_up?: string;
      offer_details?: string;
      negotiation_tips?: string;
    };
    culture_insights?: {
      work_life_balance?: string;
      team_dynamics?: string;
      management_style?: string;
      growth_opportunities?: string;
      diversity_inclusion?: string;
      remote_policy?: string;
    };
    compensation?: {
      base_salary_range?: string;
      bonus_structure?: string;
      benefits_highlights?: string;
      salary_by_level?: string;
      negotiation_room?: string;
    };
    role_specific_prep?: {
      prep_topics?: string[];
      practice_resources?: string[];
      time_investment?: string;
    };
    sources_count?: number;
    sources_summary?: string;
  };
  pdfUrl?: string;
  pdfStoragePath?: string;
  error?: string;
  completedAt?: string;
  createdAt?: string;
  userId?: string;
  userEmail?: string;
}

export interface InterviewPrep {
  id: string;
  companyName: string;
  jobTitle?: string;
  status: string;
  createdAt: string;
  pdfUrl?: string;
  error?: string;
}

// ================================
// Firm Search Types
// ================================
export interface Firm {
  id: string;
  name: string;
  website?: string;
  linkedinUrl?: string;
  location?: {
    city?: string;
    state?: string;
    country?: string;
    display?: string;
  };
  industry?: string;
  employeeCount?: number;
  sizeBucket?: 'small' | 'mid' | 'large';
  sizeRange?: string;
  founded?: number;
}

export interface FirmSearchResult {
  partialMessage?: string;  // Optional message for partial results
  success: boolean;
  firms: Firm[];
  total: number;
  parsedFilters?: {
    industry?: string;
    location?: string;
    locationNormalized?: any;
    size?: string;
    keywords?: string[];
  };
  searchId?: string;
  batchSize?: number;
  firmsReturned?: number;
  creditsCharged?: number;
  remainingCredits?: number;
  error?: string;
  insufficientCredits?: boolean;
  creditsNeeded?: number;
  currentCredits?: number;
  fallbackApplied?: boolean;
  queryLevel?: number;
}

export interface SearchHistoryItem {
  id: string;
  query: string;
  parsedFilters?: any;
  resultsCount: number;
  createdAt: string;
  results?: Firm[];  // Optional: included when includeFirms=true
}

// ================================
// Job Board Types
// ================================
export interface JobListingsRequest {
  jobTypes?: string[];
  industries?: string[];
  locations?: string[];
  refresh?: boolean;
  searchQuery?: string;
  page?: number;
  perPage?: number;
}

export interface Job {
  id: string;
  title: string;
  company: string;
  location: string;
  salary?: string;
  type: "Internship" | "Full-Time" | "Part-Time" | "Contract";
  posted: string;
  description: string;
  requirements: string[];
  url: string;
  logo?: string;
  remote?: boolean;
  experienceLevel?: string;
  via?: string;
  matchScore?: number; // Resume match score (0-100)
}

export interface JobListingsResponse {
  jobs: Job[];
  total: number;
  estimatedTotal?: number;
  page?: number;
  perPage?: number;
  hasMore?: boolean;
  source: string;
  query?: string;
  location?: string;
  cached?: boolean;
}

export interface OptimizeResumeRequest {
  jobUrl?: string;
  jobDescription?: string;
  jobTitle?: string;
  company?: string;
  userId: string;
}

export interface ATSScore {
  overall: number;
  keywords: number;
  formatting: number;
  relevance: number;
  suggestions: string[];
}

export interface OptimizedResume {
  content: string;
  atsScore: ATSScore;
  keywordsAdded: string[];
  sectionsOptimized: string[];
  warnings?: string[];
}

export interface OptimizeResumeResponse {
  optimizedResume: OptimizedResume;
  creditsUsed: number;
  creditsRemaining: number;
  processingTimeMs?: number;
}

export interface GenerateCoverLetterRequest {
  jobUrl?: string;
  jobDescription?: string;
  jobTitle?: string;
  company?: string;
  userId: string;
}

export interface CoverLetter {
  content: string;
  highlights: string[];
  tone: string;
}

export interface GenerateCoverLetterResponse {
  coverLetter: CoverLetter;
  creditsUsed: number;
  creditsRemaining: number;
}

// ================================
// Resume Optimization V2 Types
// ================================

export interface ResumeCapabilities {
  canOptimizeWithFormatting: boolean;
  canEditDirectly: boolean;
  requiresConversion: boolean;
  supportsTemplateRebuild: boolean;
  recommendedMode: 'direct_edit' | 'suggestions' | 'template_rebuild';
  availableModes?: OptimizationMode[];
}

export interface OptimizationMode {
  id: 'direct_edit' | 'suggestions' | 'template_rebuild';
  name: string;
  description: string;
  recommended: boolean;
  preservesFormatting: boolean;
}

export interface ResumeInfo {
  hasResume: boolean;
  resumeFileName?: string;
  resumeFileType?: 'pdf' | 'docx' | 'doc';
  resumeCapabilities?: ResumeCapabilities;
  resumeUploadedAt?: string;
}

export interface OptimizationSuggestion {
  section: string;
  priority: 'high' | 'medium' | 'low';
  current_text: string;
  suggested_text: string;
  reason: string;
}

export interface KeywordToAdd {
  keyword: string;
  where: string;
  reason: string;
}

export interface ScoreBreakdown {
  keyword_match: number;
  formatting: number;
  relevance: number;
}

export interface SuggestionsResult {
  mode: 'suggestions';
  success: boolean;
  formatting_preserved: boolean;
  suggestions: OptimizationSuggestion[];
  keywords_to_add: KeywordToAdd[];
  keywords_found: string[];
  overall_tips: string[];
  ats_score_estimate: number;
  score_breakdown?: ScoreBreakdown;
  message: string;
  creditsUsed: number;
  creditsRemaining: number;
}

export interface TemplateRebuildResult {
  mode: 'template_rebuild';
  success: boolean;
  formatting_preserved: boolean;
  structured_content: {
    contact: {
      name: string;
      email: string;
      phone: string;
      location: string;
      linkedin?: string;
    };
    summary: string;
    experience: Array<{
      title: string;
      company: string;
      location: string;
      startDate: string;
      endDate: string;
      bullets: string[];
    }>;
    education: Array<{
      degree: string;
      school: string;
      location: string;
      graduationDate: string;
      gpa?: string;
      coursework?: string[];
    }>;
    skills: {
      technical?: string[];
      frameworks?: string[];
      tools?: string[];
    };
    projects?: Array<{
      name: string;
      description: string;
      technologies: string[];
      bullets: string[];
    }>;
  };
  keywords_added: string[];
  ats_score_estimate: number;
  message: string;
  creditsUsed: number;
  creditsRemaining: number;
}

export interface DirectEditResult {
  mode: 'direct_edit';
  success: boolean;
  formatting_preserved: boolean;
  replacements_made: number;
  message: string;
}

export type OptimizationResult = SuggestionsResult | TemplateRebuildResult;

// ================================
// ApiService
// ================================
class ApiService {
  // ---- Auth helpers ----
  private async getIdToken(forceRefresh: boolean = false): Promise<string> {
    try {
      const { auth } = await import('../lib/firebase');
      const { onAuthStateChanged } = await import('firebase/auth');
      
      // Wait for auth state to be initialized using onAuthStateChanged
      // This ensures we wait for Firebase auth to be fully ready before checking currentUser
      // onAuthStateChanged fires immediately with the current auth state once it's determined
      let unsubscribe: (() => void) | null = null;
      const authReady = new Promise<any>((resolve, reject) => {
        const timeout = setTimeout(() => {
          if (unsubscribe) unsubscribe();
          resolve(null);
        }, 5000); // 5 second timeout
        
        unsubscribe = onAuthStateChanged(
          auth,
          (user) => {
            // onAuthStateChanged fires when auth state is determined
            // This happens immediately if auth is already initialized, or when it becomes ready
            clearTimeout(timeout);
            if (unsubscribe) unsubscribe();
            resolve(user);
          },
          (error) => {
            clearTimeout(timeout);
            if (unsubscribe) unsubscribe();
            reject(error);
          }
        );
      });
      
      const firebaseUser = await authReady;
      if (!firebaseUser) {
        console.error('No authenticated user found. Please sign in.');
        const error: any = new Error('Authentication required. Please sign in again.');
        error.status = 401;
        error.needsAuth = true;
        throw error;
      }
      
      // Get token, optionally force refresh if requested
      // Use firebaseUser directly since we've confirmed auth state is ready
      const token = await firebaseUser.getIdToken(forceRefresh);
      
      if (!token) {
        console.error('Failed to get ID token');
        const error: any = new Error('Failed to get authentication token. Please sign in again.');
        error.status = 401;
        error.needsAuth = true;
        throw error;
      }
      
      return token;
    } catch (error: any) {
      console.error('Error getting Firebase auth token:', error);
      // If it's already our custom error, re-throw it
      if (error.status === 401 && error.needsAuth) {
        throw error;
      }
      // Otherwise, wrap it
      const authError: any = new Error('Authentication required. Please sign in again.');
      authError.status = 401;
      authError.needsAuth = true;
      throw authError;
    }
  }

  private async getAuthHeaders(): Promise<Record<string, string>> {
    const headers: Record<string, string> = { 'Content-Type': 'application/json' };

    try {
      const token = await this.getIdToken();
      headers['Authorization'] = `Bearer ${token}`;
    } catch (error: any) {
      console.error('Error getting Firebase auth headers:', error);
      // If it's an auth error, preserve the status and needsAuth flag
      if (error.status === 401 && error.needsAuth) {
        throw error;
      }
      // Otherwise, wrap it
      const authError: any = new Error('Authentication required. Please sign in again.');
      authError.status = 401;
      authError.needsAuth = true;
      throw authError;
    }

    return headers;
  }

  // ---- Request helper ----
  private async makeRequest<T>(endpoint: string, options: RequestInit = {}): Promise<T> {
  const url = `${API_BASE_URL}${endpoint}`;

  // Only log in development
  const isDev = import.meta.env.DEV;
  if (isDev) {
    console.log(`Making request to: ${url}`);
    console.log(`Request options:`, options);
  }

  const response = await fetch(url, options);
  if (isDev) console.log(`Response status: ${response.status}`);

  // Check for binary/attachments first (read only once)
  const ct = response.headers.get('content-type') || '';
  const cd = response.headers.get('content-disposition') || '';
  if (ct.includes('text/csv') || ct.includes('application/pdf') || cd.includes('attachment')) {
    const blob = await response.blob();
    if (!response.ok) throw new Error(`HTTP ${response.status}: ${response.statusText}`);
    return blob as unknown as T;
  }

  // For JSON/text responses, read once
  const bodyText = await response.text();
  let data: any = {};
  if (bodyText) {
    try { data = JSON.parse(bodyText); }
    catch { data = { raw: bodyText }; }
  }

  if (!response.ok) {
    // For 401 errors, provide helpful error messages
    if (response.status === 401) {
      const error: any = new Error(
        data?.message || data?.error || 'Authentication required. Please sign in again.'
      );
      error.status = 401;
      error.needsAuth = data?.needsAuth || data?.require_reauth || true;
      error.authUrl = data?.authUrl;
      error.contacts = data?.contacts;
      
      // Log helpful debugging info
      console.error('401 Unauthorized - Authentication failed:', {
        endpoint,
        hasToken: !!options.headers?.['Authorization'],
        errorMessage: data?.error || data?.message
      });
      
      throw error;
    }
    
    // For 402 (Insufficient Credits), extract credit details from error response
    if (response.status === 402 && data) {
      const error: any = new Error(data.error || data.message || 'Insufficient credits');
      error.status = 402;
      error.error_code = data.error_code || 'INSUFFICIENT_CREDITS';
      // Extract credit details from the error response
      if (data.details) {
        error.required = data.details.required;
        error.available = data.details.available;
        error.creditsNeeded = data.details.required;
        error.currentCredits = data.details.available;
      }
      throw error;
    }
    
    // For 502 (Bad Gateway / External API Error), provide user-friendly message
    if (response.status === 502 && data) {
      const error: any = new Error(
        data.error || data.message || 'The search service is temporarily unavailable. Please try again in a few minutes.'
      );
      error.status = 502;
      error.error_code = data.error_code || 'EXTERNAL_API_ERROR';
      error.service = data.details?.service || 'Search Service';
      throw error;
    }
    
    const message =
      (data && (data.error || data.message || data.detail)) ||
      `HTTP ${response.status}: ${response.statusText}`;
    throw new Error(message);
  }

  return (data as T) ?? ({} as T);
}


  // ================================
  // Contact Search Endpoints
  // ================================

  /**
   * Free tier search - returns JSON with contacts and email data
   * Contacts are automatically saved to Contact Library on frontend
   */
  async runFreeSearch(request: ContactSearchRequest): Promise<SearchResult> {
    const headers = await this.getAuthHeaders();

    const backendRequest = {
      jobTitle: request.jobTitle,
      company: request.company,
      location: request.location,
      saveToDirectory: false, // Always false since we handle saving on frontend
      userProfile: request.userProfile,
      careerInterests: request.careerInterests || [],
      collegeAlumni: request.collegeAlumni || '', // ‚úÖ Include collegeAlumni
      batchSize: request.batchSize, // ‚úÖ Include batch size
    };

    const isDev = import.meta.env.DEV;
    if (isDev) console.log(`Free Search Request:`, backendRequest);

    return this.makeRequest<SearchResult>('/free-run', {
      method: 'POST',
      headers,
      body: JSON.stringify(backendRequest),
    });
  }

  /**
   * Pro tier search - returns JSON with contacts and email data
   * Contacts are automatically saved to Contact Library on frontend
   */
  async runProSearch(request: ProContactSearchRequest): Promise<SearchResult> {
    const idToken = await this.getIdToken();

    const formData = new FormData();
    formData.append('jobTitle', request.jobTitle);
    formData.append('company', request.company);
    formData.append('location', request.location);
    formData.append('resume', request.resume);
    formData.append('saveToDirectory', 'false'); // Always false since we handle saving on frontend
    formData.append('collegeAlumni', request.collegeAlumni || ''); // ‚úÖ Include collegeAlumni
    if (request.batchSize) {
      formData.append('batchSize', request.batchSize.toString()); // ‚úÖ Include batch size
    }

    if (request.userProfile) {
      formData.append('userProfile', JSON.stringify(request.userProfile));
    }

    if (request.careerInterests && request.careerInterests.length > 0) {
      formData.append('careerInterests', JSON.stringify(request.careerInterests));
    }

    const isDev = import.meta.env.DEV;
    if (isDev) {
      console.log(`Pro Search Request - FormData contents:`);
      console.log(`  jobTitle: "${request.jobTitle}"`);
      console.log(`  company: "${request.company}"`);
      console.log(`  location: "${request.location}"`);
      console.log(`  resume: ${request.resume.name} (${request.resume.size} bytes)`);
      console.log(`  batchSize: ${request.batchSize || 'not set'}`);
      console.log(`  userProfile: ${JSON.stringify(request.userProfile)}`);
      console.log(`  careerInterests: ${JSON.stringify(request.careerInterests)}`);
      console.log(`  collegeAlumni: "${request.collegeAlumni || ''}"`);
    }

    return this.makeRequest<SearchResult>('/pro-run', {
      method: 'POST',
      headers: {
        Authorization: `Bearer ${idToken}`,
        // Do not set Content-Type for FormData - the browser will set proper boundary
      },
      body: formData,
    });
  }

  /**
   * Optional CSV download for Free tier
   */
  async runFreeSearchCsv(request: ContactSearchRequest): Promise<Blob> {
    const headers = await this.getAuthHeaders();

    const backendRequest = {
      jobTitle: request.jobTitle,
      company: request.company,
      location: request.location,
      saveToDirectory: false,
      userProfile: request.userProfile,
      careerInterests: request.careerInterests || [],
      collegeAlumni: request.collegeAlumni || '',
    };

    return this.makeRequest<Blob>('/free-run-csv', {
      method: 'POST',
      headers,
      body: JSON.stringify(backendRequest),
    });
  }

  /**
   * Optional CSV download for Pro tier
   */
  async runProSearchCsv(request: ProContactSearchRequest): Promise<Blob> {
    const idToken = await this.getIdToken();

    const formData = new FormData();
    formData.append('jobTitle', request.jobTitle);
    formData.append('company', request.company);
    formData.append('location', request.location);
    formData.append('resume', request.resume);
    formData.append('saveToDirectory', 'false');
    formData.append('collegeAlumni', request.collegeAlumni || '');

    if (request.userProfile) {
      formData.append('userProfile', JSON.stringify(request.userProfile));
    }

    if (request.careerInterests && request.careerInterests.length > 0) {
      formData.append('careerInterests', JSON.stringify(request.careerInterests));
    }

    return this.makeRequest<Blob>('/pro-run-csv', {
      method: 'POST',
      headers: {
        Authorization: `Bearer ${idToken}`,
      },
      body: formData,
    });
  }

  // ---- Deprecated shims ----
  /** @deprecated Use runFreeSearch() instead. */
  async runBasicSearch(request: ContactSearchRequest): Promise<SearchResult> {
    console.warn('runBasicSearch is deprecated. Use runFreeSearch() instead.');
    return this.runFreeSearch(request);
  }

  /** @deprecated Advanced tier removed. Use runFreeSearch() or runProSearch(). */
  async runAdvancedSearch(request: ContactSearchRequest): Promise<SearchResult> {
    console.warn('runAdvancedSearch is deprecated. Redirecting to Free tier.');
    return this.runFreeSearch(request);
  }

  // ================================
  // Prompt Search Endpoints (Experimental)
  // ================================

  /**
   * Parse a natural language prompt into structured search filters.
   * This is a FREE operation - no credits are deducted.
   */
  async parseSearchPrompt(prompt: string): Promise<ParsedSearchFilters | ApiError> {
    const headers = await this.getAuthHeaders();
    return this.makeRequest<ParsedSearchFilters | ApiError>('/search/parse-prompt', {
      method: 'POST',
      headers,
      body: JSON.stringify({ prompt }),
    });
  }

  /**
   * Simple prompt-based search that parses prompt and returns contacts.
   * Uses existing search_contacts_with_smart_location_strategy() backend.
   */
  async promptSearch(prompt: string, maxContacts: number = 8): Promise<PromptSearchResponse | ApiError> {
    const headers = await this.getAuthHeaders();
    return this.makeRequest<PromptSearchResponse | ApiError>('/prompt-search', {
      method: 'POST',
      headers,
      body: JSON.stringify({ prompt, max_contacts: maxContacts }),
    });
  }

  // ================================
  // Coffee Chat Prep Endpoints
  // ================================

  /** Create a Coffee Chat Prep */
  async createCoffeeChatPrep(request: CoffeeChatPrepRequest): Promise<CoffeeChatPrepResponse | ApiError> {
    const headers = await this.getAuthHeaders();
    return this.makeRequest<CoffeeChatPrepResponse | ApiError>('/coffee-chat-prep', {
      method: 'POST',
      headers,
      body: JSON.stringify(request),
    });
  }

  /** Get Coffee Chat Prep status */
  async getCoffeeChatPrepStatus(prepId: string): Promise<CoffeeChatPrepStatus | ApiError> {
    const headers = await this.getAuthHeaders();
    return this.makeRequest<CoffeeChatPrepStatus | ApiError>(`/coffee-chat-prep/${prepId}`, {
      method: 'GET',
      headers,
    });
  }

  /** Get Coffee Chat PDF download URL */
  async downloadCoffeeChatPDF(prepId: string): Promise<{ pdfUrl: string }> {
    const headers = await this.getAuthHeaders();
    return this.makeRequest<{ pdfUrl: string }>(`/coffee-chat-prep/${prepId}/download`, {
      method: 'GET',
      headers,
    });
  }

  /** Get all Coffee Chat Preps for user */
  async getAllCoffeeChatPreps(): Promise<{ preps: CoffeeChatPrep[] } | ApiError> {
    const headers = await this.getAuthHeaders();
    return this.makeRequest<{ preps: CoffeeChatPrep[] } | ApiError>('/coffee-chat-prep/all', {
      method: 'GET',
      headers,
    });
  }

  /** Get Coffee Chat history (limited) */
  async getCoffeeChatHistory(limit: number = 10): Promise<{ history: CoffeeChatPrep[] } | ApiError> {
    const headers = await this.getAuthHeaders();
    return this.makeRequest<{ history: CoffeeChatPrep[] } | ApiError>(`/coffee-chat-prep/history?limit=${limit}`, {
      method: 'GET',
      headers,
    });
  }

  // ================================
  // Interview Prep Endpoints
  // ================================
  async generateInterviewPrep(request: InterviewPrepRequest): Promise<InterviewPrepResponse | ApiError> {
    const headers = await this.getAuthHeaders();
    return this.makeRequest<InterviewPrepResponse | ApiError>('/interview-prep/generate', {
      method: 'POST',
      headers,
      body: JSON.stringify(request),
    });
  }

  async getInterviewPrepStatus(prepId: string): Promise<InterviewPrepStatus | ApiError> {
    const headers = await this.getAuthHeaders();
    return this.makeRequest<InterviewPrepStatus | ApiError>(`/interview-prep/status/${prepId}`, {
      method: 'GET',
      headers,
    });
  }

  async downloadInterviewPrepPDF(prepId: string): Promise<{ pdfUrl: string; companyName?: string; jobTitle?: string }> {
    const headers = await this.getAuthHeaders();
    return this.makeRequest<{ pdfUrl: string; companyName?: string; jobTitle?: string }>(`/interview-prep/download/${prepId}`, {
      method: 'GET',
      headers,
    });
  }

  async getInterviewPrepHistory(limit: number = 10): Promise<{ history: InterviewPrep[] } | ApiError> {
    const headers = await this.getAuthHeaders();
    return this.makeRequest<{ history: InterviewPrep[] } | ApiError>(`/interview-prep/history?limit=${limit}`, {
      method: 'GET',
      headers,
    });
  }

  // ================================
  // Firm Search Endpoints
  // ================================

  async searchFirms(query: string, batchSize: number = 10): Promise<FirmSearchResult> {
    const headers = await this.getAuthHeaders();
    return this.makeRequest<FirmSearchResult>('/firm-search/search', {
      method: 'POST',
      headers,
      body: JSON.stringify({ query, batchSize }),
    });
  }

  async getFirmSearchHistory(limit: number = 10, includeFirms: boolean = false): Promise<SearchHistoryItem[]> {
    const headers = await this.getAuthHeaders();
    const includeParam = includeFirms ? '&includeFirms=true' : '';
    const result = await this.makeRequest<{ success: boolean; searches: SearchHistoryItem[] }>(`/firm-search/history?limit=${limit}${includeParam}`, {
      method: 'GET',
      headers,
    });
    return result.searches || [];
  }

  async getFirmSearchById(searchId: string): Promise<FirmSearchResult | null> {
    const headers = await this.getAuthHeaders();
    try {
      const result = await this.makeRequest<{ success: boolean; search: any }>(`/firm-search/history/${searchId}`, {
        method: 'GET',
        headers,
      });
      if (result.success && result.search) {
        return {
          success: true,
          firms: result.search.results || [],
          total: result.search.resultsCount || 0,
          parsedFilters: result.search.parsedFilters,
        };
      }
      return null;
    } catch (error) {
      console.error('Error getting firm search:', error);
      return null;
    }
  }

  async deleteFirm(firm: Firm): Promise<{ success: boolean; deletedCount?: number; error?: string }> {
    const headers = await this.getAuthHeaders();
    const deletePayload = {
      firmId: firm.id,
      firmName: firm.name,
      firmLocation: firm.location?.display,
    };
    
    console.log('üóëÔ∏è API: Deleting firm with payload:', deletePayload);
    console.log('üóëÔ∏è API: Full firm object:', JSON.stringify(firm, null, 2));
    
    try {
      const result = await this.makeRequest<{ success: boolean; deletedCount?: number; error?: string }>('/firm-search/delete-firm', {
        method: 'POST',
        headers,
        body: JSON.stringify(deletePayload),
      });
      console.log('üóëÔ∏è API: Delete result:', JSON.stringify(result, null, 2));
      if (result.success) {
        if (result.deletedCount === 0) {
          console.error('‚ùå Delete returned success but deletedCount is 0 - no firms were found to delete!');
          console.error('   This means the firm matching logic did not find any matching firms in Firebase.');
          console.error('   Check backend logs to see why matching failed.');
        } else {
          console.log(`‚úÖ Successfully deleted ${result.deletedCount} firm occurrence(s) from Firebase`);
        }
      }
      return result;
    } catch (error) {
      console.error('‚ùå API: Error deleting firm:', error);
      return {
        success: false,
        error: error instanceof Error ? error.message : 'Failed to delete firm'
      };
    }
  }

    // ================================
  // Gmail Integration Endpoints
  // ================================
  async startGmailOAuth(): Promise<string> {
    const headers = await this.getAuthHeaders();
    const { authUrl } = await this.makeRequest<{ authUrl: string }>(
      '/google/oauth/start',
      { headers }
    );
    return authUrl;
  }

  async gmailStatus(): Promise<{ connected: boolean; scopes: string[] }> {
    const headers = await this.getAuthHeaders();
    return this.makeRequest<{ connected: boolean; scopes: string[] }>(
      '/google/gmail/status',
      { headers }
    );
  }

  async saveGmailDraft(params: {
    to?: string; subject?: string; body?: string; threadId?: string;
  }): Promise<{ ok: boolean; draftId: string; messageId?: string; threadId?: string } | ApiError> {
    const headers = await this.getAuthHeaders();
    return this.makeRequest('/gmail/drafts', {
      method: 'POST',
      headers,
      body: JSON.stringify(params),
    });
  }

  // ================================
  // Misc
  // ================================

  /** Get tier information from backend */
  async getTierInfo(): Promise<{
    tiers: {
      free: {
        name: string;
        max_contacts: number;
        credits: number;
        time_saved_minutes: number;
        description: string;
        features: string[];
      };
      pro: {
        name: string;
        max_contacts: number;
        credits: number;
        time_saved_minutes: number;
        description: string;
        features: string[];
      };
    };
  }> {
    const headers = await this.getAuthHeaders();
    return this.makeRequest('/tier-info', { headers });
  }

  /** Check credits */
  async checkCredits(): Promise<{ credits: number; max_credits: number; searches_remaining: number }> {
    const headers = await this.getAuthHeaders();
    return this.makeRequest('/check-credits', { headers });
  }

  /** Health check */
  async checkHealth(): Promise<{ status: string; tiers: string[]; services: Record<string, string> }> {
    return this.makeRequest('/health');
  }
  
  /** Delete Coffee Chat Prep */
  async deleteCoffeeChatPrep(prepId: string): Promise<{ success: boolean; message: string } | ApiError> {
    const headers = await this.getAuthHeaders();
    return this.makeRequest<{ success: boolean; message: string } | ApiError>(`/coffee-chat-prep/${prepId}`, {
      method: 'DELETE',
      headers,
    });
  }
  
// ================================
// NEW: Bell Notification Endpoints
// ================================

/** Check if a contact has replied to our email */
async checkContactReplies(contactId: string): Promise<ReplyStatus | ErrorResponse> {
  const headers = await this.getAuthHeaders();
  return this.makeRequest<ReplyStatus | ErrorResponse>(`/contacts/${contactId}/check-replies`, {
    method: 'GET',
    headers,
  });
}

/** Batch check replies for multiple contacts */
async batchCheckReplies(contactIds: string[]): Promise<{ results: Record<string, ReplyStatus> } | ErrorResponse> {
  const headers = await this.getAuthHeaders();
  return this.makeRequest<{ results: Record<string, ReplyStatus> } | ErrorResponse>(
    '/contacts/batch-check-replies',
    {
      method: 'POST',
      headers,
      body: JSON.stringify({ contactIds }),
    }
  );
}

/** Mute/unmute notifications for a contact */
async muteContactNotifications(contactId: string, muted: boolean): Promise<{ success: boolean; muted: boolean } | ErrorResponse> {
  const headers = await this.getAuthHeaders();
  return this.makeRequest<{ success: boolean; muted: boolean } | ErrorResponse>(
    `/contacts/${contactId}/mute-notifications`,
    {
      method: 'POST',
      headers,
      body: JSON.stringify({ muted }),
    }
  );
}

/** Generate a reply draft for a contact's message */
async generateReplyDraft(contactId: string): Promise<GenerateReplyResult | ErrorResponse> {
  const headers = await this.getAuthHeaders();
  return this.makeRequest<GenerateReplyResult | ErrorResponse>(`/contacts/${contactId}/generate-reply`, {
    method: 'POST',
    headers,
  });
}


  // ================================
  // Dashboard API
  // ================================
  
  /** Get dashboard statistics */
  async getDashboardStats(): Promise<{
    outreachByMonth: Array<{ month: string; outreach: number; replies: number }>;
    replyStats: { totalReplies: number; responseRate: number; totalSent: number };
    topFirms: Array<{ name: string; contacts: number; replyRate: number }>;
  } | { error: string }> {
    const headers = await this.getAuthHeaders();
    return this.makeRequest('/dashboard/stats', {
      method: 'GET',
      headers,
    });
  }

  /** Get personalized recommendations */
  async getRecommendations(): Promise<{
    recommendations: Array<{
      type: string;
      title: string;
      description: string;
      action: string;
      contactId?: string;
      contactIds?: string[];
      priority?: string;
    }>;
  } | { error: string }> {
    const headers = await this.getAuthHeaders();
    return this.makeRequest('/dashboard/recommendations', {
      method: 'GET',
      headers,
    });
  }

  /** Get firm locations for map */
  async getFirmLocations(): Promise<{
    locations: Array<{
      name: string;
      city: string;
      state: string;
      contacts: number;
      coordinates: { x: number; y: number };
    }>;
  } | { error: string }> {
    const headers = await this.getAuthHeaders();
    return this.makeRequest('/dashboard/firm-locations', {
      method: 'GET',
      headers,
    });
  }

  /** Get interview prep statistics */
  async getInterviewPrepStats(): Promise<{
    total: number;
    completedThisMonth: number;
  } | { error: string }> {
    const headers = await this.getAuthHeaders();
    return this.makeRequest('/dashboard/interview-prep-stats', {
      method: 'GET',
      headers,
    });
  }

  // ================================
  // Outbox API
  // ================================
  
  /** Get all outbox email threads */
  // ================================
// Outbox API
// ================================

/** Get all Outbox email threads */
async getOutboxThreads(): Promise<{ threads: OutboxThread[] } | { error: string }> {
  const headers = await this.getAuthHeaders();

  return this.makeRequest<{ threads: OutboxThread[] } | { error: string }>(
    '/outbox/threads',
    {
      method: 'GET',
      headers
    }
  );
}

/** Regenerate a suggested reply + Gmail draft for a thread */
async regenerateOutboxReply(
  threadId: string
): Promise<{ thread: OutboxThread } | { error: string }> {
  const headers = await this.getAuthHeaders();

  return this.makeRequest<{ thread: OutboxThread } | { error: string }>(
    `/outbox/threads/${threadId}/regenerate`,
    {
      method: 'POST',
      headers,
      body: JSON.stringify({})
    }
  );
}



  /** Helper to download CSV blob as file */
  downloadCsv(blob: Blob, filename: string = 'contacts.csv') {
    const url = window.URL.createObjectURL(blob);
    const link = document.createElement('a');
    link.href = url;
    link.download = filename;
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    window.URL.revokeObjectURL(url);
  }

  // ================================
  // Timeline Endpoints
  // ================================

  /** Generate personalized recruiting timeline from a prompt */
  async generateTimeline(
    prompt: string, 
    isUpdate: boolean = false,
    existingTimeline?: {
      phases: Array<{
        name: string;
        startMonth: string;
        endMonth: string;
        goals: string[];
        description: string;
      }>;
      startDate: string;
      targetDeadline: string;
    }
  ): Promise<{
    timeline: { phases: Array<{
      name: string;
      startMonth: string;
      endMonth: string;
      goals: string[];
      description: string;
    }> };
    startDate: string;
    targetDeadline: string;
  }> {
    const headers = await this.getAuthHeaders();
    const requestBody: any = { prompt };
    
    // If updating, include existing timeline data
    if (isUpdate && existingTimeline) {
      requestBody.isUpdate = true;
      requestBody.existingTimeline = existingTimeline;
    }
    
    const response = await this.makeRequest<{ 
      success?: boolean; 
      timeline: any;
      startDate: string;
      targetDeadline: string;
    }>(
      '/timeline/generate',
      {
        method: 'POST',
        headers: {
          ...headers,
          'Content-Type': 'application/json',
        },
        body: JSON.stringify(requestBody),
      }
    );
    const isDev = import.meta.env.DEV;
    if (isDev) console.log('üì° API Response:', response);
    return {
      timeline: response.timeline || { phases: [] },
      startDate: response.startDate,
      targetDeadline: response.targetDeadline,
    };
  }

  // ================================
  // Job Board Endpoints
  // ================================

  async getJobListings(params: JobListingsRequest): Promise<JobListingsResponse> {
    const response = await this.makeRequest<JobListingsResponse>(
      '/job-board/jobs',
      {
        method: 'POST',
        headers: {
          ...await this.getAuthHeaders(),
          'Content-Type': 'application/json',
        },
        body: JSON.stringify(params),
      }
    );
    return response;
  }

  async optimizeResume(params: OptimizeResumeRequest): Promise<OptimizeResumeResponse> {
    const response = await this.makeRequest<OptimizeResumeResponse>(
      '/job-board/optimize-resume',
      {
        method: 'POST',
        headers: {
          ...await this.getAuthHeaders(),
          'Content-Type': 'application/json',
        },
        body: JSON.stringify(params),
      }
    );
    return response;
  }

  /**
   * Get the current user's resume capabilities.
   * Use this to determine what optimization modes are available.
   */
  async getResumeCapabilities(): Promise<ResumeInfo> {
    const headers = await this.getAuthHeaders();
    return this.makeRequest<ResumeInfo>('/job-board/resume-capabilities', {
      method: 'GET',
      headers,
    });
  }

  /**
   * Optimize resume with explicit mode selection.
   * 
   * @param jobDescription - The job description to optimize for (min 50 chars)
   * @param mode - The optimization mode: 'direct_edit', 'suggestions', or 'template_rebuild'
   * @param jobTitle - Optional job title
   * @param company - Optional company name
   * @param jobUrl - Optional job URL to parse
   * 
   * @returns For direct_edit: Blob (PDF file)
   * @returns For suggestions: SuggestionsResult
   * @returns For template_rebuild: TemplateRebuildResult
   */
  async optimizeResumeV2(
    jobDescription: string,
    mode: 'direct_edit' | 'suggestions' | 'template_rebuild',
    jobTitle?: string,
    company?: string,
    jobUrl?: string
  ): Promise<Blob | SuggestionsResult | TemplateRebuildResult> {
    const headers = await this.getAuthHeaders();
    
    const response = await fetch(`${API_BASE_URL}/job-board/optimize-resume-v2`, {
      method: 'POST',
      headers: {
        ...headers,
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        jobDescription,
        mode,
        jobTitle,
        company,
        jobUrl,
      }),
    });
    
    if (!response.ok) {
      const error = await response.json().catch(() => ({ error: 'Optimization failed' }));
      throw new Error(error.error || 'Optimization failed');
    }
    
    const contentType = response.headers.get('content-type');
    
    if (contentType?.includes('application/pdf')) {
      // Direct edit mode - returns PDF blob
      return response.blob();
    } else {
      // Suggestions or template rebuild - returns JSON
      return response.json();
    }
  }

  /**
   * Helper function to download a PDF blob.
   */
  downloadPdfBlob(blob: Blob, filename: string = 'optimized_resume.pdf'): void {
    const url = URL.createObjectURL(blob);
    const link = document.createElement('a');
    link.href = url;
    link.download = filename;
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    URL.revokeObjectURL(url);
  }

  /**
   * Type guard to check if result is SuggestionsResult
   */
  isSuggestionsResult(result: OptimizationResult): result is SuggestionsResult {
    return result.mode === 'suggestions';
  }

  /**
   * Type guard to check if result is TemplateRebuildResult
   */
  isTemplateRebuildResult(result: OptimizationResult): result is TemplateRebuildResult {
    return result.mode === 'template_rebuild';
  }

  async parseJobUrl(params: { url: string }): Promise<{ job?: { title?: string; company?: string; location?: string; description?: string }; error?: string }> {
    const headers = await this.getAuthHeaders();
    return this.makeRequest<{ job?: { title?: string; company?: string; location?: string; description?: string }; error?: string }>(
      '/job-board/parse-job-url',
      {
        method: 'POST',
        headers,
        body: JSON.stringify(params),
      }
    );
  }

  async findRecruiters(params: FindRecruiterRequest): Promise<FindRecruiterResponse> {
    const headers = await this.getAuthHeaders();
    return this.makeRequest<FindRecruiterResponse>(
      '/job-board/find-recruiter',
      {
        method: 'POST',
        headers,
        body: JSON.stringify(params),
      }
    );
  }

  async generateCoverLetter(params: GenerateCoverLetterRequest): Promise<GenerateCoverLetterResponse> {
    const response = await this.makeRequest<GenerateCoverLetterResponse>(
      '/job-board/generate-cover-letter',
      {
        method: 'POST',
        headers: {
          ...await this.getAuthHeaders(),
          'Content-Type': 'application/json',
        },
        body: JSON.stringify(params),
      }
    );
    return response;
  }
}

export const apiService = new ApiService();
export default apiService;

// ================================
// Standalone Helper Functions
// ================================

/**
 * Helper function to download a PDF blob.
 */
export function downloadPdfBlob(blob: Blob, filename: string = 'optimized_resume.pdf'): void {
  const url = URL.createObjectURL(blob);
  const link = document.createElement('a');
  link.href = url;
  link.download = filename;
  document.body.appendChild(link);
  link.click();
  document.body.removeChild(link);
  URL.revokeObjectURL(url);
}

/**
 * Type guard to check if result is SuggestionsResult
 */
export function isSuggestionsResult(result: OptimizationResult): result is SuggestionsResult {
  return result.mode === 'suggestions';
}

/**
 * Type guard to check if result is TemplateRebuildResult
 */
export function isTemplateRebuildResult(result: OptimizationResult): result is TemplateRebuildResult {
  return result.mode === 'template_rebuild';
}