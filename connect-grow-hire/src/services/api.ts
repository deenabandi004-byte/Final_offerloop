// src/services/api.ts
const API_BASE_URL =
  import.meta.env.VITE_API_BASE_URL ||
  (window.location.hostname === 'localhost'
    ? 'http://localhost:5001/api'
    : 'https://www.offerloop.ai/api');

export interface UserProfile {
  name?: string;
  university?: string;
  major?: string;
  year?: string;
  graduationYear?: string;
  degree?: string;
  careerInterests?: string[];
}

export interface ContactSearchRequest {
  jobTitle: string;
  company: string;
  location: string;
  uid?: string;
  saveToDirectory?: boolean;
  userProfile?: UserProfile | null;
  careerInterests?: string[];
  collegeAlumni?: string; // ✅ NEW: Added collegeAlumni field
  batchSize?: number;
}

export interface ProContactSearchRequest extends ContactSearchRequest {
  resume: File;
}

export interface Contact {
  FirstName: string;
  LastName: string;
  LinkedIn: string;
  Email: string;
  Title: string;
  Company: string;
  City: string;
  State: string;
  College: string;
  Phone?: string;
  PersonalEmail?: string;
  WorkEmail?: string;
  SocialProfiles?: string;
  EducationTop?: string;
  VolunteerHistory?: string;
  WorkSummary?: string;
  Group?: string;
  Hometown?: string;
  Similarity?: string;
  email_subject?: string; // Email subject generated by backend
  email_body?: string; // Email body generated by backend
}

// Base response type
export interface SearchResponse {
  contacts: Contact[];
  successful_drafts: number;
  total_contacts: number;
  tier: string;
  user_email: string;
  credits_used?: number;
  credits_remaining?: number;
}

// Error response type
export interface ErrorResponse {
  error: string;
  current_credits?: number;
  credits_needed?: number;
}
// ================================
// NEW: Bell Notification Types
// ================================
export interface ReplyStatus {
  hasReply: boolean;
  isUnread: boolean;
  messageId?: string;
  muted?: boolean;
}

export interface GenerateReplyResult {
  success: boolean;
  draftId: string;
  threadId: string;
  gmailUrl: string;
}

// Union type for search results
export type SearchResult = SearchResponse | ErrorResponse;

// Helper type guard
export function isErrorResponse(result: SearchResult): result is ErrorResponse {
  return 'error' in result && typeof result.error === 'string';
}

export interface FreeSearchResponse extends SearchResponse {}
export interface ProSearchResponse extends SearchResponse {}

export interface ApiError {
  error: string;
}

// ================================
// Coffee Chat Prep Types
// ================================
export interface CoffeeChatPrepRequest {
  linkedinUrl: string;
  resumeText?: string;
}

export interface CoffeeChatPrepResponse {
  prepId: string;
  status: string;
  message: string;
}

export interface CoffeeChatNewsItem {
  title: string;
  url: string;
  source: string;
  published_at?: string;
  summary: string;
  relevance_tag: 'division' | 'office' | 'industry';
  confidence?: string;
}

export interface CoffeeChatPrepStatus {
  id?: string;  // ✅ ADD THIS - backend uses 'id'
  prepId?: string;  // Keep for backwards compatibility
  status:
    | 'pending'
    | 'processing'
    | 'enriching_profile'
    | 'fetching_news'
    | 'extracting_hometown'
    | 'generating_content'
    | 'completed'
    | 'failed';
  contactData?: any;
  companyNews?: CoffeeChatNewsItem[];
  similaritySummary?: string;
  coffeeQuestions?: string[];
  pdfUrl?: string;
  pdfStoragePath?: string;
  industrySummary?: string;
  hometown?: string | null;
  context?: Record<string, any>;
  error?: string;
  completedAt?: string;  // ✅ ADD THIS
  createdAt?: string;  // ✅ ADD THIS
  linkedinUrl?: string;  // ✅ ADD THIS
  userId?: string;  // ✅ ADD THIS
  userEmail?: string;  // ✅ ADD THIS
}

export interface CoffeeChatPrep {
  id: string;
  contactName: string;
  company: string;
  jobTitle: string;
  linkedinUrl?: string;
  status: string;
  createdAt: string;
  pdfUrl?: string;
  error?: string;
  industrySummary?: string;
  hometown?: string | null;
}

// ================================
// ApiService
// ================================
class ApiService {
  // ---- Auth helpers ----
  private async getIdToken(): Promise<string> {
    try {
      const { auth } = await import('../lib/firebase');
      if (!auth.currentUser) {
        throw new Error('User not authenticated');
      }
      return await auth.currentUser.getIdToken();
    } catch (error) {
      console.error('Error getting Firebase auth token:', error);
      throw new Error('Authentication required. Please sign in again.');
    }
  }

  private async getAuthHeaders(): Promise<Record<string, string>> {
    const headers: Record<string, string> = { 'Content-Type': 'application/json' };

    try {
      const token = await this.getIdToken();
      headers['Authorization'] = `Bearer ${token}`;
    } catch (error) {
      console.error('Error getting Firebase auth headers:', error);
      throw error;
    }

    return headers;
  }

  // ---- Request helper ----
  private async makeRequest<T>(endpoint: string, options: RequestInit = {}): Promise<T> {
  const url = `${API_BASE_URL}${endpoint}`;

  console.log(`Making request to: ${url}`);
  console.log(`Request options:`, options);

  const response = await fetch(url, options);
  console.log(`Response status: ${response.status}`);

  // Check for binary/attachments first (read only once)
  const ct = response.headers.get('content-type') || '';
  const cd = response.headers.get('content-disposition') || '';
  if (ct.includes('text/csv') || ct.includes('application/pdf') || cd.includes('attachment')) {
    const blob = await response.blob();
    if (!response.ok) throw new Error(`HTTP ${response.status}: ${response.statusText}`);
    return blob as unknown as T;
  }

  // For JSON/text responses, read once
  const bodyText = await response.text();
  let data: any = {};
  if (bodyText) {
    try { data = JSON.parse(bodyText); }
    catch { data = { raw: bodyText }; }
  }

  if (!response.ok) {
    const message =
      (data && (data.error || data.message || data.detail)) ||
      `HTTP ${response.status}: ${response.statusText}`;
    throw new Error(message);
  }

  return (data as T) ?? ({} as T);
}


  // ================================
  // Contact Search Endpoints
  // ================================

  /**
   * Free tier search - returns JSON with contacts and email data
   * Contacts are automatically saved to Contact Library on frontend
   */
  async runFreeSearch(request: ContactSearchRequest): Promise<SearchResult> {
    const headers = await this.getAuthHeaders();

    const backendRequest = {
      jobTitle: request.jobTitle,
      company: request.company,
      location: request.location,
      saveToDirectory: false, // Always false since we handle saving on frontend
      userProfile: request.userProfile,
      careerInterests: request.careerInterests || [],
      collegeAlumni: request.collegeAlumni || '', // ✅ Include collegeAlumni
      batchSize: request.batchSize, // ✅ Include batch size
    };

    console.log(`Free Search Request:`, backendRequest);

    return this.makeRequest<SearchResult>('/free-run', {
      method: 'POST',
      headers,
      body: JSON.stringify(backendRequest),
    });
  }

  /**
   * Pro tier search - returns JSON with contacts and email data
   * Contacts are automatically saved to Contact Library on frontend
   */
  async runProSearch(request: ProContactSearchRequest): Promise<SearchResult> {
    const idToken = await this.getIdToken();

    const formData = new FormData();
    formData.append('jobTitle', request.jobTitle);
    formData.append('company', request.company);
    formData.append('location', request.location);
    formData.append('resume', request.resume);
    formData.append('saveToDirectory', 'false'); // Always false since we handle saving on frontend
    formData.append('collegeAlumni', request.collegeAlumni || ''); // ✅ Include collegeAlumni

    if (request.userProfile) {
      formData.append('userProfile', JSON.stringify(request.userProfile));
    }

    if (request.careerInterests && request.careerInterests.length > 0) {
      formData.append('careerInterests', JSON.stringify(request.careerInterests));
    }

    console.log(`Pro Search Request - FormData contents:`);
    console.log(`  jobTitle: "${request.jobTitle}"`);
    console.log(`  company: "${request.company}"`);
    console.log(`  location: "${request.location}"`);
    console.log(`  resume: ${request.resume.name} (${request.resume.size} bytes)`);
    console.log(`  userProfile: ${JSON.stringify(request.userProfile)}`);
    console.log(`  careerInterests: ${JSON.stringify(request.careerInterests)}`);
    console.log(`  collegeAlumni: "${request.collegeAlumni || ''}"`);

    return this.makeRequest<SearchResult>('/pro-run', {
      method: 'POST',
      headers: {
        Authorization: `Bearer ${idToken}`,
        // Do not set Content-Type for FormData - the browser will set proper boundary
      },
      body: formData,
    });
  }

  /**
   * Optional CSV download for Free tier
   */
  async runFreeSearchCsv(request: ContactSearchRequest): Promise<Blob> {
    const headers = await this.getAuthHeaders();

    const backendRequest = {
      jobTitle: request.jobTitle,
      company: request.company,
      location: request.location,
      saveToDirectory: false,
      userProfile: request.userProfile,
      careerInterests: request.careerInterests || [],
      collegeAlumni: request.collegeAlumni || '',
    };

    return this.makeRequest<Blob>('/free-run-csv', {
      method: 'POST',
      headers,
      body: JSON.stringify(backendRequest),
    });
  }

  /**
   * Optional CSV download for Pro tier
   */
  async runProSearchCsv(request: ProContactSearchRequest): Promise<Blob> {
    const idToken = await this.getIdToken();

    const formData = new FormData();
    formData.append('jobTitle', request.jobTitle);
    formData.append('company', request.company);
    formData.append('location', request.location);
    formData.append('resume', request.resume);
    formData.append('saveToDirectory', 'false');
    formData.append('collegeAlumni', request.collegeAlumni || '');

    if (request.userProfile) {
      formData.append('userProfile', JSON.stringify(request.userProfile));
    }

    if (request.careerInterests && request.careerInterests.length > 0) {
      formData.append('careerInterests', JSON.stringify(request.careerInterests));
    }

    return this.makeRequest<Blob>('/pro-run-csv', {
      method: 'POST',
      headers: {
        Authorization: `Bearer ${idToken}`,
      },
      body: formData,
    });
  }

  // ---- Deprecated shims ----
  /** @deprecated Use runFreeSearch() instead. */
  async runBasicSearch(request: ContactSearchRequest): Promise<SearchResult> {
    console.warn('runBasicSearch is deprecated. Use runFreeSearch() instead.');
    return this.runFreeSearch(request);
  }

  /** @deprecated Advanced tier removed. Use runFreeSearch() or runProSearch(). */
  async runAdvancedSearch(request: ContactSearchRequest): Promise<SearchResult> {
    console.warn('runAdvancedSearch is deprecated. Redirecting to Free tier.');
    return this.runFreeSearch(request);
  }

  // ================================
  // Coffee Chat Prep Endpoints
  // ================================

  /** Create a Coffee Chat Prep */
  async createCoffeeChatPrep(request: CoffeeChatPrepRequest): Promise<CoffeeChatPrepResponse | ApiError> {
    const headers = await this.getAuthHeaders();
    return this.makeRequest<CoffeeChatPrepResponse | ApiError>('/coffee-chat-prep', {
      method: 'POST',
      headers,
      body: JSON.stringify(request),
    });
  }

  /** Get Coffee Chat Prep status */
  async getCoffeeChatPrepStatus(prepId: string): Promise<CoffeeChatPrepStatus | ApiError> {
    const headers = await this.getAuthHeaders();
    return this.makeRequest<CoffeeChatPrepStatus | ApiError>(`/coffee-chat-prep/${prepId}`, {
      method: 'GET',
      headers,
    });
  }

  /** Get Coffee Chat PDF download URL */
  async downloadCoffeeChatPDF(prepId: string): Promise<{ pdfUrl: string }> {
    const headers = await this.getAuthHeaders();
    return this.makeRequest<{ pdfUrl: string }>(`/coffee-chat-prep/${prepId}/download`, {
      method: 'GET',
      headers,
    });
  }

  /** Get all Coffee Chat Preps for user */
  async getAllCoffeeChatPreps(): Promise<{ preps: CoffeeChatPrep[] } | ApiError> {
    const headers = await this.getAuthHeaders();
    return this.makeRequest<{ preps: CoffeeChatPrep[] } | ApiError>('/coffee-chat-prep/all', {
      method: 'GET',
      headers,
    });
  }

  /** Get Coffee Chat history (limited) */
  async getCoffeeChatHistory(limit: number = 10): Promise<{ history: CoffeeChatPrep[] } | ApiError> {
    const headers = await this.getAuthHeaders();
    return this.makeRequest<{ history: CoffeeChatPrep[] } | ApiError>(`/coffee-chat-prep/history?limit=${limit}`, {
      method: 'GET',
      headers,
    });
  }

 

    // ================================
  // Gmail Integration Endpoints
  // ================================
  async startGmailOAuth(): Promise<string> {
    const headers = await this.getAuthHeaders();
    const { authUrl } = await this.makeRequest<{ authUrl: string }>(
      '/google/oauth/start',
      { headers }
    );
    return authUrl;
  }

  async gmailStatus(): Promise<{ connected: boolean; scopes: string[] }> {
    const headers = await this.getAuthHeaders();
    return this.makeRequest<{ connected: boolean; scopes: string[] }>(
      '/gmail/status',
      { headers }
    );
  }

  async saveGmailDraft(params: {
    to?: string; subject?: string; body?: string; threadId?: string;
  }): Promise<{ ok: boolean; draftId: string; messageId?: string; threadId?: string } | ApiError> {
    const headers = await this.getAuthHeaders();
    return this.makeRequest('/gmail/drafts', {
      method: 'POST',
      headers,
      body: JSON.stringify(params),
    });
  }

  // ================================
  // Misc
  // ================================

  /** Get tier information from backend */
  async getTierInfo(): Promise<{
    tiers: {
      free: {
        name: string;
        max_contacts: number;
        credits: number;
        time_saved_minutes: number;
        description: string;
        features: string[];
      };
      pro: {
        name: string;
        max_contacts: number;
        credits: number;
        time_saved_minutes: number;
        description: string;
        features: string[];
      };
    };
  }> {
    const headers = await this.getAuthHeaders();
    return this.makeRequest('/tier-info', { headers });
  }

  /** Check credits */
  async checkCredits(): Promise<{ credits: number; max_credits: number; searches_remaining: number }> {
    const headers = await this.getAuthHeaders();
    return this.makeRequest('/check-credits', { headers });
  }

  /** Health check */
  async checkHealth(): Promise<{ status: string; tiers: string[]; services: Record<string, string> }> {
    return this.makeRequest('/health');
  }
  /** Delete Coffee Chat Prep */
async deleteCoffeeChatPrep(prepId: string): Promise<{ success: boolean; message: string } | ApiError> {
  const headers = await this.getAuthHeaders();
  return this.makeRequest<{ success: boolean; message: string } | ApiError>(`/coffee-chat-prep/${prepId}`, {
    method: 'DELETE',
    headers,
  });
}
// ================================
// NEW: Bell Notification Endpoints
// ================================

/** Check if a contact has replied to our email */
async checkContactReplies(contactId: string): Promise<ReplyStatus | ErrorResponse> {
  const headers = await this.getAuthHeaders();
  return this.makeRequest<ReplyStatus | ErrorResponse>(`/contacts/${contactId}/check-replies`, {
    method: 'GET',
    headers,
  });
}

/** Batch check replies for multiple contacts */
async batchCheckReplies(contactIds: string[]): Promise<{ results: Record<string, ReplyStatus> } | ErrorResponse> {
  const headers = await this.getAuthHeaders();
  return this.makeRequest<{ results: Record<string, ReplyStatus> } | ErrorResponse>(
    '/contacts/batch-check-replies',
    {
      method: 'POST',
      headers,
      body: JSON.stringify({ contactIds }),
    }
  );
}

/** Mute/unmute notifications for a contact */
async muteContactNotifications(contactId: string, muted: boolean): Promise<{ success: boolean; muted: boolean } | ErrorResponse> {
  const headers = await this.getAuthHeaders();
  return this.makeRequest<{ success: boolean; muted: boolean } | ErrorResponse>(
    `/contacts/${contactId}/mute-notifications`,
    {
      method: 'POST',
      headers,
      body: JSON.stringify({ muted }),
    }
  );
}

/** Generate a reply draft for a contact's message */
async generateReplyDraft(contactId: string): Promise<GenerateReplyResult | ErrorResponse> {
  const headers = await this.getAuthHeaders();
  return this.makeRequest<GenerateReplyResult | ErrorResponse>(`/contacts/${contactId}/generate-reply`, {
    method: 'POST',
    headers,
  });
}


  /** Helper to download CSV blob as file */
  downloadCsv(blob: Blob, filename: string = 'contacts.csv') {
    const url = window.URL.createObjectURL(blob);
    const link = document.createElement('a');
    link.href = url;
    link.download = filename;
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    window.URL.revokeObjectURL(url);
  }
}

export const apiService = new ApiService();
export default apiService;
