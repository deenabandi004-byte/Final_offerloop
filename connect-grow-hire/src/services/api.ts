// src/services/api.ts
const API_BASE_URL =
  import.meta.env.VITE_API_BASE_URL ||
  (window.location.hostname === 'localhost'
    ? 'http://localhost:5001/api'
    : 'https://www.offerloop.ai/api');

export interface UserProfile {
  name?: string;
  university?: string;
  major?: string;
  year?: string;
  graduationYear?: string;
  degree?: string;
  careerInterests?: string[];
}

export interface ContactSearchRequest {
  jobTitle: string;
  company: string;
  location: string;
  uid?: string;
  saveToDirectory?: boolean;
  userProfile?: UserProfile | null;
  careerInterests?: string[];
  collegeAlumni?: string; // ✅ NEW: Added collegeAlumni field
  batchSize?: number;
}

export interface ProContactSearchRequest extends ContactSearchRequest {
  resume: File;
}

export interface Contact {
  FirstName: string;
  LastName: string;
  LinkedIn: string;
  Email: string;
  Title: string;
  Company: string;
  City: string;
  State: string;
  College: string;
  Phone?: string;
  PersonalEmail?: string;
  WorkEmail?: string;
  SocialProfiles?: string;
  EducationTop?: string;
  VolunteerHistory?: string;
  WorkSummary?: string;
  Group?: string;
  Hometown?: string;
  Similarity?: string;
  email_subject?: string; // Email subject generated by backend
  email_body?: string; // Email body generated by backend
}

// Base response type
export interface SearchResponse {
  contacts: Contact[];
  successful_drafts: number;
  total_contacts: number;
  tier: string;
  user_email: string;
  credits_used?: number;
  credits_remaining?: number;
}

// Error response type
export interface ErrorResponse {
  error: string;
  current_credits?: number;
  credits_needed?: number;
}

// Union type for search results
export type SearchResult = SearchResponse | ErrorResponse;

// Helper type guard
export function isErrorResponse(result: SearchResult): result is ErrorResponse {
  return 'error' in result && typeof result.error === 'string';
}

export interface FreeSearchResponse extends SearchResponse {}
export interface ProSearchResponse extends SearchResponse {}

export interface ApiError {
  error: string;
}

// ================================
// Coffee Chat Prep Types
// ================================
export interface CoffeeChatPrepRequest {
  linkedinUrl: string;
  resumeText?: string;
}

export interface CoffeeChatPrepResponse {
  prepId: string;
  status: string;
  message: string;
}

export interface CoffeeChatPrepStatus {
  id?: string;  // ✅ ADD THIS - backend uses 'id'
  prepId?: string;  // Keep for backwards compatibility
  status:
    | 'pending'
    | 'processing'
    | 'enriching_profile'
    | 'fetching_news'
    | 'extracting_hometown'
    | 'generating_content'
    | 'completed'
    | 'failed';
  contactData?: any;
  companyNews?: any[];
  similaritySummary?: string;
  coffeeQuestions?: string[];
  pdfUrl?: string;
  pdfPath?: string;  // ✅ ADD THIS - backend uses this
  error?: string;
  completedAt?: string;  // ✅ ADD THIS
  createdAt?: string;  // ✅ ADD THIS
  linkedinUrl?: string;  // ✅ ADD THIS
  userId?: string;  // ✅ ADD THIS
  userEmail?: string;  // ✅ ADD THIS
}

export interface CoffeeChatPrep {
  id: string;
  contactName: string;
  company: string;
  jobTitle: string;
  linkedinUrl: string;
  status: string;
  createdAt: string;
  pdfUrl?: string;
  error?: string;
}

// ================================
// ApiService
// ================================
class ApiService {
  // ---- Auth helpers ----
  private async getIdToken(): Promise<string> {
    try {
      const { auth } = await import('../lib/firebase');
      if (!auth.currentUser) {
        throw new Error('User not authenticated');
      }
      return await auth.currentUser.getIdToken();
    } catch (error) {
      console.error('Error getting Firebase auth token:', error);
      throw new Error('Authentication required. Please sign in again.');
    }
  }

  private async getAuthHeaders(): Promise<Record<string, string>> {
    const headers: Record<string, string> = { 'Content-Type': 'application/json' };

    try {
      const token = await this.getIdToken();
      headers['Authorization'] = `Bearer ${token}`;
    } catch (error) {
      console.error('Error getting Firebase auth headers:', error);
      throw error;
    }

    return headers;
  }

  // ---- Request helper ----
  private async makeRequest<T>(endpoint: string, options: RequestInit = {}): Promise<T> {
    const url = `${API_BASE_URL}${endpoint}`;

    console.log(`Making request to: ${url}`);
    console.log(`Request options:`, options);

    const response = await fetch(url, options);

    console.log(`Response status: ${response.status}`);

    if (!response.ok) {
      const errorData = await response.json().catch(() => ({}));
      console.error(`API Error:`, errorData);

      // Return error response instead of throwing (so callers can use union types)
      if (errorData.error) {
        return errorData as T;
      }

      throw new Error(errorData.error || `HTTP ${response.status}: ${response.statusText}`);
    }

    // CSV or attachment: return Blob
    const ct = response.headers.get('content-type') || '';
    const cd = response.headers.get('content-disposition') || '';
    if (ct.includes('text/csv') || cd.includes('attachment')) {
      console.log(`Returning Blob`);
      return (await response.blob()) as unknown as T;
    }

    if (ct.includes('application/pdf')) {
      return (await response.blob()) as unknown as T;
    }

    return response.json();
  }

  // ================================
  // Contact Search Endpoints
  // ================================

  /**
   * Free tier search - returns JSON with contacts and email data
   * Contacts are automatically saved to Contact Library on frontend
   */
  async runFreeSearch(request: ContactSearchRequest): Promise<SearchResult> {
    const headers = await this.getAuthHeaders();

    const backendRequest = {
      jobTitle: request.jobTitle,
      company: request.company,
      location: request.location,
      saveToDirectory: false, // Always false since we handle saving on frontend
      userProfile: request.userProfile,
      careerInterests: request.careerInterests || [],
      collegeAlumni: request.collegeAlumni || '', // ✅ Include collegeAlumni
      batchSize: request.batchSize, // ✅ Include batch size
    };

    console.log(`Free Search Request:`, backendRequest);

    return this.makeRequest<SearchResult>('/free-run', {
      method: 'POST',
      headers,
      body: JSON.stringify(backendRequest),
    });
  }

  /**
   * Pro tier search - returns JSON with contacts and email data
   * Contacts are automatically saved to Contact Library on frontend
   */
  async runProSearch(request: ProContactSearchRequest): Promise<SearchResult> {
    const idToken = await this.getIdToken();

    const formData = new FormData();
    formData.append('jobTitle', request.jobTitle);
    formData.append('company', request.company);
    formData.append('location', request.location);
    formData.append('resume', request.resume);
    formData.append('saveToDirectory', 'false'); // Always false since we handle saving on frontend
    formData.append('collegeAlumni', request.collegeAlumni || ''); // ✅ Include collegeAlumni

    if (request.userProfile) {
      formData.append('userProfile', JSON.stringify(request.userProfile));
    }

    if (request.careerInterests && request.careerInterests.length > 0) {
      formData.append('careerInterests', JSON.stringify(request.careerInterests));
    }

    console.log(`Pro Search Request - FormData contents:`);
    console.log(`  jobTitle: "${request.jobTitle}"`);
    console.log(`  company: "${request.company}"`);
    console.log(`  location: "${request.location}"`);
    console.log(`  resume: ${request.resume.name} (${request.resume.size} bytes)`);
    console.log(`  userProfile: ${JSON.stringify(request.userProfile)}`);
    console.log(`  careerInterests: ${JSON.stringify(request.careerInterests)}`);
    console.log(`  collegeAlumni: "${request.collegeAlumni || ''}"`);

    return this.makeRequest<SearchResult>('/pro-run', {
      method: 'POST',
      headers: {
        Authorization: `Bearer ${idToken}`,
        // Do not set Content-Type for FormData - the browser will set proper boundary
      },
      body: formData,
    });
  }

  /**
   * Optional CSV download for Free tier
   */
  async runFreeSearchCsv(request: ContactSearchRequest): Promise<Blob> {
    const headers = await this.getAuthHeaders();

    const backendRequest = {
      jobTitle: request.jobTitle,
      company: request.company,
      location: request.location,
      saveToDirectory: false,
      userProfile: request.userProfile,
      careerInterests: request.careerInterests || [],
      collegeAlumni: request.collegeAlumni || '',
    };

    return this.makeRequest<Blob>('/free-run-csv', {
      method: 'POST',
      headers,
      body: JSON.stringify(backendRequest),
    });
  }

  /**
   * Optional CSV download for Pro tier
   */
  async runProSearchCsv(request: ProContactSearchRequest): Promise<Blob> {
    const idToken = await this.getIdToken();

    const formData = new FormData();
    formData.append('jobTitle', request.jobTitle);
    formData.append('company', request.company);
    formData.append('location', request.location);
    formData.append('resume', request.resume);
    formData.append('saveToDirectory', 'false');
    formData.append('collegeAlumni', request.collegeAlumni || '');

    if (request.userProfile) {
      formData.append('userProfile', JSON.stringify(request.userProfile));
    }

    if (request.careerInterests && request.careerInterests.length > 0) {
      formData.append('careerInterests', JSON.stringify(request.careerInterests));
    }

    return this.makeRequest<Blob>('/pro-run-csv', {
      method: 'POST',
      headers: {
        Authorization: `Bearer ${idToken}`,
      },
      body: formData,
    });
  }

  // ---- Deprecated shims ----
  /** @deprecated Use runFreeSearch() instead. */
  async runBasicSearch(request: ContactSearchRequest): Promise<SearchResult> {
    console.warn('runBasicSearch is deprecated. Use runFreeSearch() instead.');
    return this.runFreeSearch(request);
  }

  /** @deprecated Advanced tier removed. Use runFreeSearch() or runProSearch(). */
  async runAdvancedSearch(request: ContactSearchRequest): Promise<SearchResult> {
    console.warn('runAdvancedSearch is deprecated. Redirecting to Free tier.');
    return this.runFreeSearch(request);
  }

  // ================================
  // Coffee Chat Prep Endpoints
  // ================================

  /** Create a Coffee Chat Prep */
  async createCoffeeChatPrep(request: CoffeeChatPrepRequest): Promise<CoffeeChatPrepResponse | ApiError> {
    const headers = await this.getAuthHeaders();
    return this.makeRequest<CoffeeChatPrepResponse | ApiError>('/coffee-chat-prep', {
      method: 'POST',
      headers,
      body: JSON.stringify(request),
    });
  }

  /** Get Coffee Chat Prep status */
  async getCoffeeChatPrepStatus(prepId: string): Promise<CoffeeChatPrepStatus | ApiError> {
    const headers = await this.getAuthHeaders();
    return this.makeRequest<CoffeeChatPrepStatus | ApiError>(`/coffee-chat-prep/${prepId}`, {
      method: 'GET',
      headers,
    });
  }

  /** Download Coffee Chat PDF */
  async downloadCoffeeChatPDF(prepId: string): Promise<Blob> {
    const headers = await this.getAuthHeaders();
    return this.makeRequest<Blob>(`/coffee-chat-prep/${prepId}/download`, {
      method: 'GET',
      headers,
    });
  }

  /** Get all Coffee Chat Preps for user */
  async getAllCoffeeChatPreps(): Promise<{ preps: CoffeeChatPrep[] } | ApiError> {
    const headers = await this.getAuthHeaders();
    return this.makeRequest<{ preps: CoffeeChatPrep[] } | ApiError>('/coffee-chat-prep/all', {
      method: 'GET',
      headers,
    });
  }

  /** Get Coffee Chat history (limited) */
  async getCoffeeChatHistory(limit: number = 10): Promise<{ history: CoffeeChatPrep[] } | ApiError> {
    const headers = await this.getAuthHeaders();
    return this.makeRequest<{ history: CoffeeChatPrep[] } | ApiError>(`/coffee-chat-prep/history?limit=${limit}`, {
      method: 'GET',
      headers,
    });
  }

  // ================================
  // Misc
  // ================================

  /** Get tier information from backend */
  async getTierInfo(): Promise<{
    tiers: {
      free: {
        name: string;
        max_contacts: number;
        credits: number;
        time_saved_minutes: number;
        description: string;
        features: string[];
      };
      pro: {
        name: string;
        max_contacts: number;
        credits: number;
        time_saved_minutes: number;
        description: string;
        features: string[];
      };
    };
  }> {
    const headers = await this.getAuthHeaders();
    return this.makeRequest('/tier-info', { headers });
  }

  /** Check credits */
  async checkCredits(): Promise<{ credits: number; max_credits: number; searches_remaining: number }> {
    const headers = await this.getAuthHeaders();
    return this.makeRequest('/check-credits', { headers });
  }

  /** Health check */
  async checkHealth(): Promise<{ status: string; tiers: string[]; services: Record<string, string> }> {
    return this.makeRequest('/health');
  }
  /** Delete Coffee Chat Prep */
async deleteCoffeeChatPrep(prepId: string): Promise<{ success: boolean; message: string } | ApiError> {
  const headers = await this.getAuthHeaders();
  return this.makeRequest<{ success: boolean; message: string } | ApiError>(`/coffee-chat-prep/${prepId}`, {
    method: 'DELETE',
    headers,
  });
}

  /** Helper to download CSV blob as file */
  downloadCsv(blob: Blob, filename: string = 'contacts.csv') {
    const url = window.URL.createObjectURL(blob);
    const link = document.createElement('a');
    link.href = url;
    link.download = filename;
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    window.URL.revokeObjectURL(url);
  }
}

export const apiService = new ApiService();
export default apiService;
