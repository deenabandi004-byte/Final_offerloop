import{d as o}from"./index-CbRDpcOQ.js";import{d as l,e as m,u as g,q as A,t as u,v as S,w as D,x as f,f as w,y as I,T as k,z as O,A as E}from"./vendor-firebase-fqjS7TZQ.js";const v={async createUser(a,t){const e=l(o,"users",a);await w(e,{...t,createdAt:t.createdAt||new Date().toISOString(),lastLogin:new Date().toISOString()},{merge:!0})},async getUser(a){const t=l(o,"users",a),e=await m(t);return e.exists()?e.data():null},async updateUser(a,t){const e=l(o,"users",a);await g(e,{...t,lastLogin:new Date().toISOString()})},async updateCredits(a,t){const e=l(o,"users",a);await g(e,{credits:t})},async saveProfessionalInfo(a,t){const e=l(o,"users",a);await g(e,{professionalInfo:t,needsOnboarding:!1})},async getProfessionalInfo(a){const t=l(o,"users",a),e=await m(t);return e.exists()&&e.data().professionalInfo||null},async createContact(a,t){const e=u(o,"users",a,"contacts"),s=l(e),n={...t,createdAt:new Date().toISOString(),updatedAt:new Date().toISOString()};return await w(s,n),s.id},async bulkCreateContacts(a,t){const e=E(o),s=u(o,"users",a,"contacts");for(const n of t){const i=l(s),c={...n,createdAt:new Date().toISOString(),updatedAt:new Date().toISOString()};e.set(i,c)}await e.commit()},async getContacts(a){const t=u(o,"users",a,"contacts");return(await f(t)).docs.map(s=>({id:s.id,...s.data()}))},async getContact(a,t){const e=l(o,"users",a,"contacts",t),s=await m(e);return s.exists()?{id:s.id,...s.data()}:null},async updateContact(a,t,e){const s=l(o,"users",a,"contacts",t);await g(s,{...e,updatedAt:new Date().toISOString()})},async deleteContact(a,t){const e=l(o,"users",a,"contacts",t);await A(e)},async clearAllContacts(a){const t=u(o,"users",a,"contacts"),e=await f(t),s=E(o);e.docs.forEach(n=>s.delete(n.ref)),await s.commit()},async findContactByEmail(a,t){const e=u(o,"users",a,"contacts"),s=S(e,O("email","==",t)),n=await f(s);if(n.empty)return null;const i=n.docs[0];return{id:i.id,...i.data()}},async logActivity(a,t,e,s){try{console.log("üìù Logging activity:",{uid:a,type:t,summary:e,metadata:s});const n=u(o,"users",a,"activity"),i=l(n);await w(i,{type:t,summary:e,timestamp:k.now(),metadata:s||{}}),console.log("‚úÖ Activity logged successfully")}catch(n){throw console.error("‚ùå Failed to log activity:",n),n}},async getActivities(a,t=10){try{const e=u(o,"users",a,"activity");let s;try{const n=S(e,D("timestamp","desc"),I(t));s=await f(n)}catch(n){return console.warn("Firestore index may be missing, fetching all activities and sorting client-side:",n),(await f(e)).docs.map(r=>({id:r.id,...r.data()})).filter(r=>r.timestamp).sort((r,d)=>{var y,C,p,R;const h=((C=(y=r.timestamp)==null?void 0:y.toMillis)==null?void 0:C.call(y))||0;return(((R=(p=d.timestamp)==null?void 0:p.toMillis)==null?void 0:R.call(p))||0)-h}).slice(0,t)}return s.docs.map(n=>({id:n.id,...n.data()}))}catch(e){return console.error("Error fetching activities:",e),[]}},async getGoals(a){try{const t=u(o,"users",a,"goals");return(await f(t)).docs.map(s=>({id:s.id,...s.data()}))}catch(t){return console.error("Error fetching goals:",t),[]}},async createGoal(a,t){try{const e=u(o,"users",a,"goals"),s=l(e);return await w(s,t),s.id}catch(e){throw console.error("Error creating goal:",e),e}},async updateUserStreak(a,t){try{const e=l(o,"users",a);await g(e,{currentStreak:t.currentStreak,longestStreak:t.longestStreak,lastActivityDate:t.lastActivityDate})}catch(e){console.error("Error updating user streak:",e)}},async getUserStreak(a){try{const t=l(o,"users",a),e=await m(t);if(!e.exists())return null;const s=e.data();return{currentStreak:s.currentStreak||0,longestStreak:s.longestStreak||0,lastActivityDate:s.lastActivityDate||null}}catch(t){return console.error("Error fetching user streak:",t),null}},async createCalendarEvent(a,t){try{const e=u(o,"users",a,"calendar_events"),s=l(e),n={title:t.title,contactName:t.contactName,firm:t.firm,date:t.date,time:t.time,duration:t.duration,type:t.type,status:t.status,createdAt:new Date().toISOString(),updatedAt:new Date().toISOString()};return t.contactId&&(n.contactId=t.contactId),t.meetingLink&&(n.meetingLink=t.meetingLink),t.notes&&(n.notes=t.notes),await w(s,n),s.id}catch(e){throw console.error("Error creating calendar event:",e),e}},async getCalendarEvents(a,t,e){try{const s=u(o,"users",a,"calendar_events");let n;try{const c=S(s,D("date","asc"),D("time","asc"));n=await f(c)}catch(c){console.warn("Firestore index may be missing, fetching all events and sorting client-side:",c),n=await f(s)}let i=n.docs.map(c=>({id:c.id,...c.data()}));return i.sort((c,r)=>{const d=c.date.localeCompare(r.date);return d!==0?d:c.time.localeCompare(r.time)}),t!==void 0&&e!==void 0&&(i=i.filter(c=>{if(!c.date)return!1;const[r,d]=c.date.split("-").map(Number);return d-1===t&&r===e})),console.log(`üìÖ Fetched ${i.length} calendar events for month ${t}, year ${e}`),i}catch(s){return console.error("Error fetching calendar events:",s),[]}},async updateCalendarEvent(a,t,e){try{const s=l(o,"users",a,"calendar_events",t),n={updatedAt:new Date().toISOString()};Object.keys(e).forEach(i=>{const c=e[i];c!==void 0&&(n[i]=c)}),await g(s,n)}catch(s){throw console.error("Error updating calendar event:",s),s}},async deleteCalendarEvent(a,t){try{const e=l(o,"users",a,"calendar_events",t);await A(e)}catch(e){throw console.error("Error deleting calendar event:",e),e}},async getFollowUpReminders(a){try{const t=await v.getContacts(a),e=new Date,s=new Date(e);s.setDate(s.getDate()-3);const n=await v.getCalendarEvents(a),i=new Set(n.filter(r=>new Date(`${r.date}T${r.time}`)>e).map(r=>r.contactId).filter(Boolean)),c=[];for(const r of t)if(!(r.id&&i.has(r.id))&&!(r.status==="Replied"||r.status==="Meeting Scheduled")&&r.firstContactDate){const d=new Date(r.firstContactDate);if(d<s){const h=Math.floor((e.getTime()-d.getTime())/864e5);c.push({id:r.id||"",contactId:r.id||"",contactName:`${r.firstName} ${r.lastName}`.trim()||r.email,firm:r.company||"",daysSinceContact:h,lastContactDate:r.firstContactDate})}}return c.sort((r,d)=>d.daysSinceContact-r.daysSinceContact),c}catch(t){return console.error("Error fetching follow-up reminders:",t),[]}},async searchContacts(a,t,e=10){try{const s=await v.getContacts(a),n=t.toLowerCase();return s.filter(i=>{const c=`${i.firstName} ${i.lastName}`.toLowerCase(),r=i.email.toLowerCase(),d=(i.company||"").toLowerCase();return c.includes(n)||r.includes(n)||d.includes(n)}).slice(0,e)}catch(s){return console.error("Error searching contacts:",s),[]}},async saveTimeline(a,t){const e=l(o,"users",a);await g(e,{timeline:{...t,updatedAt:new Date().toISOString()}})},async getTimeline(a){try{const t=l(o,"users",a),e=await m(t);if(!e.exists())return console.log("‚ùå User document does not exist"),null;const n=e.data().timeline;return!n||!n.phases||n.phases.length===0?(console.log("‚ùå No timeline data found in user document"),null):(console.log("‚úÖ Found timeline in Firestore:",n),{...n,lastPrompt:n.lastPrompt||""})}catch(t){return console.error("‚ùå Error getting timeline:",t),null}}};export{v as f};
